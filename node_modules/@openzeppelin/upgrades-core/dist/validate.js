"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isUpgradeSafe = exports.getErrors = exports.ValidationErrors = exports.assertUpgradeSafe = exports.getUnlinkedBytecode = exports.getStorageLayout = exports.getContractVersion = exports.validate = exports.withValidationDefaults = void 0;
const utils_1 = require("solidity-ast/utils");
const chalk_1 = __importDefault(require("chalk"));
const version_1 = require("./version");
const storage_1 = require("./storage");
const link_refs_1 = require("./link-refs");
const error_1 = require("./error");
const is_nullish_1 = require("./utils/is-nullish");
function withValidationDefaults(opts) {
    var _a, _b;
    return {
        unsafeAllowCustomTypes: (_a = opts.unsafeAllowCustomTypes) !== null && _a !== void 0 ? _a : false,
        unsafeAllowLinkedLibraries: (_b = opts.unsafeAllowLinkedLibraries) !== null && _b !== void 0 ? _b : false,
    };
}
exports.withValidationDefaults = withValidationDefaults;
function validate(solcOutput, decodeSrc) {
    const validation = {};
    const fromId = {};
    const inheritIds = {};
    const libraryIds = {};
    for (const source in solcOutput.contracts) {
        for (const contractName in solcOutput.contracts[source]) {
            const bytecode = solcOutput.contracts[source][contractName].evm.bytecode;
            const version = bytecode.object === '' ? undefined : version_1.getVersion(bytecode.object);
            const linkReferences = link_refs_1.extractLinkReferences(bytecode);
            validation[contractName] = {
                version,
                inherit: [],
                libraries: [],
                linkReferences,
                errors: [],
                layout: {
                    storage: [],
                    types: {},
                },
            };
        }
        for (const contractDef of utils_1.findAll('ContractDefinition', solcOutput.sources[source].ast)) {
            fromId[contractDef.id] = contractDef.name;
            if (contractDef.name in validation) {
                const { bytecode } = solcOutput.contracts[source][contractDef.name].evm;
                inheritIds[contractDef.name] = contractDef.linearizedBaseContracts.slice(1);
                libraryIds[contractDef.name] = getReferencedLibraryIds(contractDef);
                validation[contractDef.name].errors = [
                    ...getConstructorErrors(contractDef, decodeSrc),
                    ...getDelegateCallErrors(contractDef, decodeSrc),
                    ...getStateVariableErrors(contractDef, decodeSrc),
                    // TODO: add support for structs and enums
                    // https://github.com/OpenZeppelin/openzeppelin-upgrades/issues/3
                    ...getStructErrors(contractDef, decodeSrc),
                    ...getEnumErrors(contractDef, decodeSrc),
                    // TODO: add linked libraries support
                    // https://github.com/OpenZeppelin/openzeppelin-upgrades/issues/52
                    ...getLinkingErrors(contractDef, bytecode),
                ];
                validation[contractDef.name].layout = storage_1.extractStorageLayout(contractDef, decodeSrc);
            }
        }
    }
    for (const contractName in inheritIds) {
        validation[contractName].inherit = inheritIds[contractName].map(id => fromId[id]);
    }
    for (const contractName in libraryIds) {
        validation[contractName].libraries = libraryIds[contractName].map(id => fromId[id]);
    }
    return validation;
}
exports.validate = validate;
function getContractVersion(validation, contractName) {
    const { version } = validation[contractName];
    if (version === undefined) {
        throw new Error(`Contract ${contractName} is abstract`);
    }
    return version;
}
exports.getContractVersion = getContractVersion;
function getContractName(validation, version) {
    const contractName = Object.keys(validation).find(name => { var _a; return ((_a = validation[name].version) === null || _a === void 0 ? void 0 : _a.withMetadata) === version.withMetadata; });
    if (contractName === undefined) {
        throw new Error('The requested contract was not found. Make sure the source code is available for compilation');
    }
    return contractName;
}
function getStorageLayout(validation, version) {
    const contractName = getContractName(validation, version);
    const c = validation[contractName];
    const layout = { storage: [], types: {} };
    for (const name of [contractName].concat(c.inherit)) {
        layout.storage.unshift(...validation[name].layout.storage);
        Object.assign(layout.types, validation[name].layout.types);
    }
    return layout;
}
exports.getStorageLayout = getStorageLayout;
function getUnlinkedBytecode(validation, bytecode) {
    var _a;
    const linkableContracts = Object.keys(validation).filter(name => validation[name].linkReferences.length > 0);
    for (const name of linkableContracts) {
        const { linkReferences } = validation[name];
        const unlinkedBytecode = link_refs_1.unlinkBytecode(bytecode, linkReferences);
        const version = version_1.getVersion(unlinkedBytecode);
        if (((_a = validation[name].version) === null || _a === void 0 ? void 0 : _a.withMetadata) === version.withMetadata) {
            return unlinkedBytecode;
        }
    }
    return bytecode;
}
exports.getUnlinkedBytecode = getUnlinkedBytecode;
function assertUpgradeSafe(validation, version, opts) {
    const contractName = getContractName(validation, version);
    let errors = getErrors(validation, version);
    errors = processExceptions(contractName, errors, opts);
    if (errors.length > 0) {
        throw new ValidationErrors(contractName, errors);
    }
}
exports.assertUpgradeSafe = assertUpgradeSafe;
function processExceptions(contractName, errorsToProcess, opts) {
    const { unsafeAllowCustomTypes, unsafeAllowLinkedLibraries } = withValidationDefaults(opts);
    let errors = errorsToProcess;
    // Process `unsafeAllowCustomTypes` flag
    if (unsafeAllowCustomTypes) {
        errors = processOverride(contractName, errors, ['enum-definition', 'struct-definition'], `    You are using the \`unsafeAllowCustomTypes\` flag to skip storage checks for structs and enums.\n` +
            `    Make sure you have manually checked the storage layout for incompatibilities.\n`);
    }
    // Process `unsafeAllowLinkedLibraries` flag
    if (unsafeAllowLinkedLibraries) {
        errors = processOverride(contractName, errors, ['external-library-linking'], `    You are using the \`unsafeAllowLinkedLibraries\` flag to include external libraries.\n` +
            `    Make sure you have manually checked that the linked libraries are upgrade safe.\n`);
    }
    return errors;
}
function processOverride(contractName, errorsToProcess, overrides, message) {
    let errors = errorsToProcess;
    let exceptionsFound = false;
    errors = errors.filter(error => {
        const isException = overrides.includes(error.kind);
        exceptionsFound = exceptionsFound || isException;
        return !isException;
    });
    if (exceptionsFound) {
        console.error('\n' +
            chalk_1.default.keyword('orange').bold('Warning: ') +
            `Potentially unsafe deployment of ${contractName}\n\n` +
            message);
    }
    return errors;
}
class ValidationErrors extends error_1.UpgradesError {
    constructor(contractName, errors) {
        super(`Contract \`${contractName}\` is not upgrade safe`, () => {
            return errors.map(describeError).join('\n\n');
        });
        this.errors = errors;
    }
}
exports.ValidationErrors = ValidationErrors;
const errorInfo = {
    constructor: {
        msg: e => `Contract \`${e.contract}\` has a constructor`,
        hint: 'Define an initializer instead',
        link: 'https://zpl.in/upgrades/error-001',
    },
    delegatecall: {
        msg: () => `Use of delegatecall is not allowed`,
        link: 'https://zpl.in/upgrades/error-002',
    },
    selfdestruct: {
        msg: () => `Use of selfdestruct is not allowed`,
        link: 'https://zpl.in/upgrades/error-003',
    },
    'state-variable-assignment': {
        msg: e => `Variable \`${e.name}\` is assigned an initial value`,
        hint: 'Move the assignment to the initializer',
        link: 'https://zpl.in/upgrades/error-004',
    },
    'state-variable-immutable': {
        msg: e => `Variable \`${e.name}\` is immutable`,
        hint: `Use a constant or mutable variable instead`,
        link: 'https://zpl.in/upgrades/error-005',
    },
    'external-library-linking': {
        msg: e => `Linking external libraries like \`${e.name}\` is not yet supported`,
        hint: `Use libraries with internal functions only, or skip this check with the \`unsafeAllowLinkedLibraries\` flag \n` +
            `    if you have manually checked that the libraries are upgrade safe`,
        link: 'https://zpl.in/upgrades/error-006',
    },
    'struct-definition': {
        msg: e => `Defining structs like \`${e.name}\` is not yet supported`,
        hint: `If you have manually checked for storage layout compatibility, you can skip this check with the \`unsafeAllowCustomTypes\` flag`,
        link: 'https://zpl.in/upgrades/error-007',
    },
    'enum-definition': {
        msg: e => `Defining enums like \`${e.name}\` is not yet supported`,
        hint: `If you have manually checked for storage layout compatibility, you can skip this check with the \`unsafeAllowCustomTypes\` flag`,
        link: 'https://zpl.in/upgrades/error-007',
    },
};
function describeError(e) {
    const info = errorInfo[e.kind];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const log = [chalk_1.default.bold(e.src) + ': ' + info.msg(e)];
    if (info.hint) {
        log.push(info.hint);
    }
    if (info.link) {
        log.push(chalk_1.default.dim(info.link));
    }
    return log.join('\n    ');
}
function getErrors(validation, version) {
    const contractName = getContractName(validation, version);
    const c = validation[contractName];
    return c.errors
        .concat(...c.inherit.map(name => validation[name].errors))
        .concat(...c.libraries.map(name => validation[name].errors));
}
exports.getErrors = getErrors;
function isUpgradeSafe(validation, version) {
    return getErrors(validation, version).length == 0;
}
exports.isUpgradeSafe = isUpgradeSafe;
function* getConstructorErrors(contractDef, decodeSrc) {
    var _a, _b;
    for (const fnDef of utils_1.findAll('FunctionDefinition', contractDef)) {
        if (fnDef.kind === 'constructor' && (((_b = (_a = fnDef.body) === null || _a === void 0 ? void 0 : _a.statements.length) !== null && _b !== void 0 ? _b : 0) > 0 || fnDef.modifiers.length > 0)) {
            yield {
                kind: 'constructor',
                contract: contractDef.name,
                src: decodeSrc(fnDef),
            };
        }
    }
}
function* getDelegateCallErrors(contractDef, decodeSrc) {
    var _a, _b;
    for (const fnCall of utils_1.findAll('FunctionCall', contractDef)) {
        const fn = fnCall.expression;
        if ((_a = fn.typeDescriptions.typeIdentifier) === null || _a === void 0 ? void 0 : _a.match(/^t_function_baredelegatecall_/)) {
            yield {
                kind: 'delegatecall',
                src: decodeSrc(fnCall),
            };
        }
        if ((_b = fn.typeDescriptions.typeIdentifier) === null || _b === void 0 ? void 0 : _b.match(/^t_function_selfdestruct_/)) {
            yield {
                kind: 'selfdestruct',
                src: decodeSrc(fnCall),
            };
        }
    }
}
function* getStateVariableErrors(contractDef, decodeSrc) {
    for (const varDecl of contractDef.nodes) {
        if (utils_1.isNodeType('VariableDeclaration', varDecl)) {
            if (!varDecl.constant && !is_nullish_1.isNullish(varDecl.value)) {
                yield {
                    kind: 'state-variable-assignment',
                    name: varDecl.name,
                    src: decodeSrc(varDecl),
                };
            }
            if (varDecl.mutability === 'immutable') {
                yield {
                    kind: 'state-variable-immutable',
                    name: varDecl.name,
                    src: decodeSrc(varDecl),
                };
            }
        }
    }
}
function getReferencedLibraryIds(contractDef) {
    const implicitUsage = [...utils_1.findAll('UsingForDirective', contractDef)].map(usingForDirective => usingForDirective.libraryName.referencedDeclaration);
    const explicitUsage = [...utils_1.findAll('Identifier', contractDef)]
        .filter(identifier => { var _a; return (_a = identifier.typeDescriptions.typeString) === null || _a === void 0 ? void 0 : _a.match(/^type\(library/); })
        .map(identifier => {
        if (is_nullish_1.isNullish(identifier.referencedDeclaration)) {
            throw new Error('Broken invariant: Identifier.referencedDeclaration should not be null');
        }
        return identifier.referencedDeclaration;
    });
    return [...new Set(implicitUsage.concat(explicitUsage))];
}
function* getLinkingErrors(contractDef, bytecode) {
    const { linkReferences } = bytecode;
    for (const source of Object.keys(linkReferences)) {
        for (const libName of Object.keys(linkReferences[source])) {
            yield {
                kind: 'external-library-linking',
                name: libName,
                src: source,
            };
        }
    }
}
function* getStructErrors(contractDef, decodeSrc) {
    for (const structDefinition of utils_1.findAll('StructDefinition', contractDef)) {
        yield {
            kind: 'struct-definition',
            name: structDefinition.name,
            src: decodeSrc(structDefinition),
        };
    }
}
function* getEnumErrors(contractDef, decodeSrc) {
    for (const enumDefinition of utils_1.findAll('EnumDefinition', contractDef)) {
        yield {
            kind: 'enum-definition',
            name: enumDefinition.name,
            src: decodeSrc(enumDefinition),
        };
    }
}
//# sourceMappingURL=validate.js.map