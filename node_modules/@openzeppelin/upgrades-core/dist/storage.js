"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stabilizeTypeIdentifier = exports.decodeTypeIdentifier = exports.getStorageUpgradeErrors = exports.describeError = exports.assertStorageUpgradeSafe = exports.extractStorageLayout = void 0;
const assert_1 = __importDefault(require("assert"));
const chalk_1 = __importDefault(require("chalk"));
const utils_1 = require("solidity-ast/utils");
const levenshtein_1 = require("./levenshtein");
const error_1 = require("./error");
function extractStorageLayout(contractDef, decodeSrc) {
    const layout = { storage: [], types: {} };
    for (const varDecl of contractDef.nodes) {
        if (utils_1.isNodeType('VariableDeclaration', varDecl)) {
            if (!varDecl.constant && varDecl.mutability !== 'immutable') {
                const { typeIdentifier, typeString } = varDecl.typeDescriptions;
                assert_1.default(typeof typeIdentifier === 'string');
                assert_1.default(typeof typeString === 'string');
                const type = decodeTypeIdentifier(typeIdentifier);
                layout.storage.push({
                    contract: contractDef.name,
                    label: varDecl.name,
                    type,
                    src: decodeSrc(varDecl),
                });
                layout.types[type] = {
                    label: typeString,
                };
            }
        }
    }
    return layout;
}
exports.extractStorageLayout = extractStorageLayout;
function assertStorageUpgradeSafe(original, updated, unsafeAllowCustomTypes = false) {
    let errors = getStorageUpgradeErrors(original, updated);
    if (unsafeAllowCustomTypes) {
        errors = errors
            .filter(error => error.kind === 'typechange')
            .filter(error => {
            const { original, updated } = error;
            if (original && updated) {
                // Skip storage errors if the only difference seems to be the AST id number
                return stabilizeTypeIdentifier(original === null || original === void 0 ? void 0 : original.type) !== stabilizeTypeIdentifier(updated === null || updated === void 0 ? void 0 : updated.type);
            }
            return error;
        });
    }
    if (errors.length > 0) {
        throw new StorageUpgradeErrors(errors);
    }
}
exports.assertStorageUpgradeSafe = assertStorageUpgradeSafe;
class StorageUpgradeErrors extends error_1.UpgradesError {
    constructor(errors) {
        super(`New storage layout is incompatible due to the following changes`, () => {
            return errors.map(describeError).join('\n\n');
        });
        this.errors = errors;
    }
}
function label(variable) {
    return (variable === null || variable === void 0 ? void 0 : variable.label) ? '`' + variable.label + '`' : '<unknown>';
}
const errorInfo = {
    typechange: {
        msg: o => `Type of variable ${label(o.updated)} was changed`,
    },
    rename: {
        msg: o => `Variable ${label(o.original)} was renamed`,
    },
    replace: {
        msg: o => `Variable ${label(o.original)} was replaced with ${label(o.updated)}`,
    },
    insert: {
        msg: o => `Inserted variable ${label(o.updated)}`,
        hint: 'Only insert variables at the end of the most derived contract',
    },
    delete: {
        msg: o => `Deleted variable ${label(o.original)}`,
        hint: 'Keep the variable even if unused',
    },
    append: {
        // this would not be shown to the user but TypeScript needs append here
        msg: () => 'Appended a variable but it is not an error',
    },
};
function describeError(e) {
    var _a, _b, _c, _d;
    const info = errorInfo[e.kind];
    const src = (_d = (_b = (_a = e.updated) === null || _a === void 0 ? void 0 : _a.src) !== null && _b !== void 0 ? _b : (_c = e.original) === null || _c === void 0 ? void 0 : _c.contract) !== null && _d !== void 0 ? _d : 'unknown';
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const log = [chalk_1.default.bold(src) + ': ' + info.msg(e)];
    if (info.hint) {
        log.push(info.hint);
    }
    if (info.link) {
        log.push(chalk_1.default.dim(info.link));
    }
    return log.join('\n    ');
}
exports.describeError = describeError;
function getStorageUpgradeErrors(original, updated) {
    function matchStorageItem(o, u) {
        const nameMatches = o.label === u.label;
        // TODO: type matching should compare struct members, etc.
        const typeMatches = original.types[o.type].label === updated.types[u.type].label;
        if (typeMatches && nameMatches) {
            return 'equal';
        }
        else if (typeMatches) {
            return 'rename';
        }
        else if (nameMatches) {
            return 'typechange';
        }
        else {
            return 'replace';
        }
    }
    const ops = levenshtein_1.levenshtein(original.storage, updated.storage, matchStorageItem);
    return ops.filter(o => o.kind !== 'append');
}
exports.getStorageUpgradeErrors = getStorageUpgradeErrors;
// Type Identifiers in the AST are for some reason encoded so that they don't
// contain parentheses or commas, which have been substituted as follows:
//    (  ->  $_
//    )  ->  _$
//    ,  ->  _$_
// This is particularly hard to decode because it is not a prefix-free code.
// Thus, the following regex has to perform a lookahead to make sure it gets
// the substitution right.
function decodeTypeIdentifier(typeIdentifier) {
    return typeIdentifier.replace(/(\$_|_\$_|_\$)(?=(\$_|_\$_|_\$)*([^_$]|$))/g, m => {
        switch (m) {
            case '$_':
                return '(';
            case '_$':
                return ')';
            case '_$_':
                return ',';
            default:
                throw new Error('Unreachable');
        }
    });
}
exports.decodeTypeIdentifier = decodeTypeIdentifier;
// Type Identifiers contain AST id numbers, which makes them sensitive to
// unrelated changes in the source code. This function stabilizes a type
// identifier by removing all AST ids.
function stabilizeTypeIdentifier(typeIdentifier) {
    let decoded = decodeTypeIdentifier(typeIdentifier);
    const re = /(t_struct|t_enum|t_contract)\(/g;
    let match;
    while ((match = re.exec(decoded))) {
        let i;
        let d = 1;
        for (i = match.index + match[0].length; d !== 0; i++) {
            assert_1.default(i < decoded.length, 'index out of bounds');
            const c = decoded[i];
            if (c === '(') {
                d += 1;
            }
            else if (c === ')') {
                d -= 1;
            }
        }
        const re2 = /\d+_?/y;
        re2.lastIndex = i;
        decoded = decoded.replace(re2, '');
    }
    return decoded;
}
exports.stabilizeTypeIdentifier = stabilizeTypeIdentifier;
//# sourceMappingURL=storage.js.map