"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLinkedBytecode = exports.validateArtifacts = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const utils_1 = require("solidity-ast/utils");
const upgrades_core_1 = require("@openzeppelin/upgrades-core");
async function validateArtifacts(artifactsPath, sourcesPath) {
    const artifacts = await readArtifacts(artifactsPath);
    const { input, output } = reconstructSolcInputOutput(artifacts);
    const srcDecoder = upgrades_core_1.solcInputOutputDecoder(input, output, sourcesPath);
    return upgrades_core_1.validate(output, srcDecoder);
}
exports.validateArtifacts = validateArtifacts;
async function readArtifacts(artifactsPath) {
    const artifactNames = await fs_1.promises.readdir(artifactsPath);
    const artifactContents = await Promise.all(artifactNames.map(n => fs_1.promises.readFile(path_1.default.join(artifactsPath, n), 'utf8')));
    return artifactContents.map(c => JSON.parse(c));
}
function reconstructSolcInputOutput(artifacts) {
    const output = { contracts: {}, sources: {} };
    const input = { sources: {} };
    const sourceUnitId = {};
    for (const artifact of artifacts) {
        if (artifact.ast === undefined) {
            throw new Error('Artifact does not contain AST');
        }
        const { contractName, sourcePath, ast } = artifact;
        if (input.sources[sourcePath] === undefined) {
            input.sources[sourcePath] = { content: artifact.source };
        }
        if (output.sources[sourcePath] === undefined) {
            const [, , id] = ast.src.split(':').map(Number);
            output.sources[sourcePath] = { ast, id };
            sourceUnitId[sourcePath] = ast.id;
        }
        if (output.contracts[sourcePath] === undefined) {
            output.contracts[sourcePath] = {};
        }
        output.contracts[sourcePath][contractName] = {
            evm: {
                bytecode: {
                    object: artifact.bytecode,
                    linkReferences: reconstructLinkReferences(artifact.bytecode),
                },
            },
        };
    }
    for (const { ast } of Object.values(output.sources)) {
        for (const importDir of utils_1.findAll('ImportDirective', ast)) {
            const importedUnitId = sourceUnitId[importDir.absolutePath];
            if (importedUnitId !== importDir.sourceUnit) {
                throw new Error(`Artifacts are from different compiler runs\n` +
                    `    Run a full recompilation using \`truffle compile --all\`\n` +
                    `    https://zpl.in/upgrades/truffle-recompile-all`);
            }
        }
    }
    return { input, output };
}
function reconstructLinkReferences(bytecode) {
    var _a, _b;
    var _c;
    const linkReferences = {};
    const delimiter = '__';
    const length = 20;
    // Extract placeholders from bytecode
    for (let index = 0; index < bytecode.length;) {
        const pos = bytecode.indexOf(delimiter, index);
        if (pos === -1) {
            break;
        }
        // Process link reference
        const placeHolder = bytecode.substr(pos, length);
        const libName = placeHolder.substr(2, placeHolder.indexOf(delimiter, 2) - 2);
        (_a = linkReferences['*']) !== null && _a !== void 0 ? _a : (linkReferences['*'] = {});
        (_b = (_c = linkReferences['*'])[libName]) !== null && _b !== void 0 ? _b : (_c[libName] = []);
        linkReferences['*'][libName].push({ length, start: pos / 2 });
        index += pos + length * 2;
    }
    return linkReferences;
}
async function getLinkedBytecode(Contract, provider) {
    var _a;
    const networkId = await upgrades_core_1.getNetworkId(provider);
    const networkInfo = (_a = Contract.networks) === null || _a === void 0 ? void 0 : _a[networkId];
    let linkedBytecode = Contract.bytecode;
    for (const name in networkInfo === null || networkInfo === void 0 ? void 0 : networkInfo.links) {
        const address = (networkInfo === null || networkInfo === void 0 ? void 0 : networkInfo.links[name].replace(/^0x/, '')) || '';
        const regex = new RegExp(`__${name}_+`, 'g');
        linkedBytecode = linkedBytecode.replace(regex, address);
    }
    return linkedBytecode;
}
exports.getLinkedBytecode = getLinkedBytecode;
//# sourceMappingURL=validate.js.map