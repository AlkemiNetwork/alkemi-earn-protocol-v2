{
	"schemaVersion": "2.0.0",
	"contractName": "FluxAggregatorTestHelper",
	"compilerOutput": {
		"abi": [
			{
				"anonymous": false,
				"inputs": [],
				"name": "Here",
				"type": "event"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"internalType": "address",
						"name": "from",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "to",
						"type": "address"
					}
				],
				"name": "OwnershipTransferRequested",
				"type": "event"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"internalType": "address",
						"name": "from",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "to",
						"type": "address"
					}
				],
				"name": "OwnershipTransferred",
				"type": "event"
			},
			{
				"inputs": [],
				"name": "acceptOwnership",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "owner",
				"outputs": [
					{
						"internalType": "address payable",
						"name": "",
						"type": "address"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_aggregator",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "_roundID",
						"type": "uint256"
					}
				],
				"name": "readGetAnswer",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_aggregator",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "_roundID",
						"type": "uint256"
					}
				],
				"name": "readGetTimestamp",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_aggregator",
						"type": "address"
					}
				],
				"name": "readLatestAnswer",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_aggregator",
						"type": "address"
					}
				],
				"name": "readLatestTimestamp",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_aggregator",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "_oracle",
						"type": "address"
					}
				],
				"name": "readOracleRoundState",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_to",
						"type": "address"
					}
				],
				"name": "transferOwnership",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			}
		],
		"devdoc": {
			"methods": {
				"acceptOwnership()": {
					"details": "Allows an ownership transfer to be completed by the recipient."
				},
				"transferOwnership(address)": {
					"details": "Allows an owner to begin transferring ownership to a new address, pending."
				}
			}
		},
		"evm": {
			"bytecode": {
				"linkReferences": {},
				"object": "0x6080604052600080546001600160a01b031916331790556106e0806100256000396000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c8063c52a1f5e1161005b578063c52a1f5e14610134578063c9592ab91461016f578063d2f79c47146101a8578063f2fde38b146101db57610088565b806379ba50971461008d5780638da5cb5b14610097578063bf5fc18b146100c8578063c0c9c7db14610101575b600080fd5b61009561020e565b005b61009f610310565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b610095600480360360408110156100de57600080fd5b5073ffffffffffffffffffffffffffffffffffffffff813516906020013561032c565b6100956004803603602081101561011757600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166103d6565b6100956004803603604081101561014a57600080fd5b5073ffffffffffffffffffffffffffffffffffffffff81358116916020013516610474565b6100956004803603604081101561018557600080fd5b5073ffffffffffffffffffffffffffffffffffffffff8135169060200135610517565b610095600480360360208110156101be57600080fd5b503573ffffffffffffffffffffffffffffffffffffffff16610568565b610095600480360360208110156101f157600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166105ae565b60015473ffffffffffffffffffffffffffffffffffffffff16331461029457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4d7573742062652070726f706f736564206f776e657200000000000000000000604482015290519081900360640190fd5b60008054337fffffffffffffffffffffffff00000000000000000000000000000000000000008083168217845560018054909116905560405173ffffffffffffffffffffffffffffffffffffffff90921692909183917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a350565b60005473ffffffffffffffffffffffffffffffffffffffff1681565b8173ffffffffffffffffffffffffffffffffffffffff1663b5ab58dc826040518263ffffffff1660e01b81526004018082815260200191505060206040518083038186803b15801561037d57600080fd5b505afa158015610391573d6000803e3d6000fd5b505050506040513d60208110156103a757600080fd5b50506040517ffe92bbc330eb12cd316e909741296a7fbde0684922f2564d9a9021f08959374090600090a15050565b8073ffffffffffffffffffffffffffffffffffffffff166350d25bcd6040518163ffffffff1660e01b815260040160206040518083038186803b15801561041c57600080fd5b505afa158015610430573d6000803e3d6000fd5b505050506040513d602081101561044657600080fd5b50506040517ffe92bbc330eb12cd316e909741296a7fbde0684922f2564d9a9021f08959374090600090a150565b604080517f88aa80e700000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152600060248301529151918416916388aa80e79160448082019261010092909190829003018186803b1580156104ec57600080fd5b505afa158015610500573d6000803e3d6000fd5b505050506040513d6101008110156103a757600080fd5b8173ffffffffffffffffffffffffffffffffffffffff1663b633620c826040518263ffffffff1660e01b81526004018082815260200191505060206040518083038186803b15801561037d57600080fd5b8073ffffffffffffffffffffffffffffffffffffffff16638205bf6a6040518163ffffffff1660e01b815260040160206040518083038186803b15801561041c57600080fd5b60005473ffffffffffffffffffffffffffffffffffffffff16331461063457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4f6e6c792063616c6c61626c65206279206f776e657200000000000000000000604482015290519081900360640190fd5b600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83811691821790925560008054604051929316917fed8889f560326eb138920d842192f0eb3dd22b4f139c87a2c57538e05bae12789190a35056fea2646970667358221220072aee894006ab958cd2d22f722dcacfdff5705a1313b742d62b7a2fba4c1fcc64736f6c63430006060033",
				"opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT AND CALLER OR SWAP1 SSTORE PUSH2 0x6E0 DUP1 PUSH2 0x25 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x88 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0xC52A1F5E GT PUSH2 0x5B JUMPI DUP1 PUSH4 0xC52A1F5E EQ PUSH2 0x134 JUMPI DUP1 PUSH4 0xC9592AB9 EQ PUSH2 0x16F JUMPI DUP1 PUSH4 0xD2F79C47 EQ PUSH2 0x1A8 JUMPI DUP1 PUSH4 0xF2FDE38B EQ PUSH2 0x1DB JUMPI PUSH2 0x88 JUMP JUMPDEST DUP1 PUSH4 0x79BA5097 EQ PUSH2 0x8D JUMPI DUP1 PUSH4 0x8DA5CB5B EQ PUSH2 0x97 JUMPI DUP1 PUSH4 0xBF5FC18B EQ PUSH2 0xC8 JUMPI DUP1 PUSH4 0xC0C9C7DB EQ PUSH2 0x101 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x95 PUSH2 0x20E JUMP JUMPDEST STOP JUMPDEST PUSH2 0x9F PUSH2 0x310 JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF SWAP1 SWAP3 AND DUP3 MSTORE MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 RETURN JUMPDEST PUSH2 0x95 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0xDE JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP2 CALLDATALOAD AND SWAP1 PUSH1 0x20 ADD CALLDATALOAD PUSH2 0x32C JUMP JUMPDEST PUSH2 0x95 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x117 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP CALLDATALOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH2 0x3D6 JUMP JUMPDEST PUSH2 0x95 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x14A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP2 CALLDATALOAD DUP2 AND SWAP2 PUSH1 0x20 ADD CALLDATALOAD AND PUSH2 0x474 JUMP JUMPDEST PUSH2 0x95 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x185 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP2 CALLDATALOAD AND SWAP1 PUSH1 0x20 ADD CALLDATALOAD PUSH2 0x517 JUMP JUMPDEST PUSH2 0x95 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x1BE JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP CALLDATALOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH2 0x568 JUMP JUMPDEST PUSH2 0x95 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x1F1 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP CALLDATALOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH2 0x5AE JUMP JUMPDEST PUSH1 0x1 SLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER EQ PUSH2 0x294 JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x16 PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x4D7573742062652070726F706F736564206F776E657200000000000000000000 PUSH1 0x44 DUP3 ADD MSTORE SWAP1 MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x64 ADD SWAP1 REVERT JUMPDEST PUSH1 0x0 DUP1 SLOAD CALLER PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 DUP1 DUP4 AND DUP3 OR DUP5 SSTORE PUSH1 0x1 DUP1 SLOAD SWAP1 SWAP2 AND SWAP1 SSTORE PUSH1 0x40 MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF SWAP1 SWAP3 AND SWAP3 SWAP1 SWAP2 DUP4 SWAP2 PUSH32 0x8BE0079C531659141344CD1FD0A4F28419497F9722A3DAAFE3B4186F6B6457E0 SWAP2 LOG3 POP JUMP JUMPDEST PUSH1 0x0 SLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 JUMP JUMPDEST DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH4 0xB5AB58DC DUP3 PUSH1 0x40 MLOAD DUP3 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x37D JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x391 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x3A7 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP POP PUSH1 0x40 MLOAD PUSH32 0xFE92BBC330EB12CD316E909741296A7FBDE0684922F2564D9A9021F089593740 SWAP1 PUSH1 0x0 SWAP1 LOG1 POP POP JUMP JUMPDEST DUP1 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH4 0x50D25BCD PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x41C JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x430 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x446 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP POP PUSH1 0x40 MLOAD PUSH32 0xFE92BBC330EB12CD316E909741296A7FBDE0684922F2564D9A9021F089593740 SWAP1 PUSH1 0x0 SWAP1 LOG1 POP JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD PUSH32 0x88AA80E700000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP4 DUP2 AND PUSH1 0x4 DUP4 ADD MSTORE PUSH1 0x0 PUSH1 0x24 DUP4 ADD MSTORE SWAP2 MLOAD SWAP2 DUP5 AND SWAP2 PUSH4 0x88AA80E7 SWAP2 PUSH1 0x44 DUP1 DUP3 ADD SWAP3 PUSH2 0x100 SWAP3 SWAP1 SWAP2 SWAP1 DUP3 SWAP1 SUB ADD DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x4EC JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x500 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH2 0x100 DUP2 LT ISZERO PUSH2 0x3A7 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH4 0xB633620C DUP3 PUSH1 0x40 MLOAD DUP3 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x37D JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH4 0x8205BF6A PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x41C JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 SLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER EQ PUSH2 0x634 JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x16 PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x4F6E6C792063616C6C61626C65206279206F776E657200000000000000000000 PUSH1 0x44 DUP3 ADD MSTORE SWAP1 MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x64 ADD SWAP1 REVERT JUMPDEST PUSH1 0x1 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP4 DUP2 AND SWAP2 DUP3 OR SWAP1 SWAP3 SSTORE PUSH1 0x0 DUP1 SLOAD PUSH1 0x40 MLOAD SWAP3 SWAP4 AND SWAP2 PUSH32 0xED8889F560326EB138920D842192F0EB3DD22B4F139C87A2C57538E05BAE1278 SWAP2 SWAP1 LOG3 POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 SMOD 0x2A 0xEE DUP10 BLOCKHASH MOD 0xAB SWAP6 DUP13 0xD2 0xD2 0x2F PUSH19 0x2DCACFDFF5705A1313B742D62B7A2FBA4C1FCC PUSH5 0x736F6C6343 STOP MOD MOD STOP CALLER ",
				"sourceMap": "58:831:38:-:0;;;414:5:10;:18;;-1:-1:-1;;;;;;414:18:10;422:10;414:18;;;58:831:38;;;;;;"
			},
			"deployedBytecode": {
				"immutableReferences": {},
				"linkReferences": {},
				"object": "0x608060405234801561001057600080fd5b50600436106100885760003560e01c8063c52a1f5e1161005b578063c52a1f5e14610134578063c9592ab91461016f578063d2f79c47146101a8578063f2fde38b146101db57610088565b806379ba50971461008d5780638da5cb5b14610097578063bf5fc18b146100c8578063c0c9c7db14610101575b600080fd5b61009561020e565b005b61009f610310565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b610095600480360360408110156100de57600080fd5b5073ffffffffffffffffffffffffffffffffffffffff813516906020013561032c565b6100956004803603602081101561011757600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166103d6565b6100956004803603604081101561014a57600080fd5b5073ffffffffffffffffffffffffffffffffffffffff81358116916020013516610474565b6100956004803603604081101561018557600080fd5b5073ffffffffffffffffffffffffffffffffffffffff8135169060200135610517565b610095600480360360208110156101be57600080fd5b503573ffffffffffffffffffffffffffffffffffffffff16610568565b610095600480360360208110156101f157600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166105ae565b60015473ffffffffffffffffffffffffffffffffffffffff16331461029457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4d7573742062652070726f706f736564206f776e657200000000000000000000604482015290519081900360640190fd5b60008054337fffffffffffffffffffffffff00000000000000000000000000000000000000008083168217845560018054909116905560405173ffffffffffffffffffffffffffffffffffffffff90921692909183917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a350565b60005473ffffffffffffffffffffffffffffffffffffffff1681565b8173ffffffffffffffffffffffffffffffffffffffff1663b5ab58dc826040518263ffffffff1660e01b81526004018082815260200191505060206040518083038186803b15801561037d57600080fd5b505afa158015610391573d6000803e3d6000fd5b505050506040513d60208110156103a757600080fd5b50506040517ffe92bbc330eb12cd316e909741296a7fbde0684922f2564d9a9021f08959374090600090a15050565b8073ffffffffffffffffffffffffffffffffffffffff166350d25bcd6040518163ffffffff1660e01b815260040160206040518083038186803b15801561041c57600080fd5b505afa158015610430573d6000803e3d6000fd5b505050506040513d602081101561044657600080fd5b50506040517ffe92bbc330eb12cd316e909741296a7fbde0684922f2564d9a9021f08959374090600090a150565b604080517f88aa80e700000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152600060248301529151918416916388aa80e79160448082019261010092909190829003018186803b1580156104ec57600080fd5b505afa158015610500573d6000803e3d6000fd5b505050506040513d6101008110156103a757600080fd5b8173ffffffffffffffffffffffffffffffffffffffff1663b633620c826040518263ffffffff1660e01b81526004018082815260200191505060206040518083038186803b15801561037d57600080fd5b8073ffffffffffffffffffffffffffffffffffffffff16638205bf6a6040518163ffffffff1660e01b815260040160206040518083038186803b15801561041c57600080fd5b60005473ffffffffffffffffffffffffffffffffffffffff16331461063457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4f6e6c792063616c6c61626c65206279206f776e657200000000000000000000604482015290519081900360640190fd5b600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83811691821790925560008054604051929316917fed8889f560326eb138920d842192f0eb3dd22b4f139c87a2c57538e05bae12789190a35056fea2646970667358221220072aee894006ab958cd2d22f722dcacfdff5705a1313b742d62b7a2fba4c1fcc64736f6c63430006060033",
				"opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x88 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0xC52A1F5E GT PUSH2 0x5B JUMPI DUP1 PUSH4 0xC52A1F5E EQ PUSH2 0x134 JUMPI DUP1 PUSH4 0xC9592AB9 EQ PUSH2 0x16F JUMPI DUP1 PUSH4 0xD2F79C47 EQ PUSH2 0x1A8 JUMPI DUP1 PUSH4 0xF2FDE38B EQ PUSH2 0x1DB JUMPI PUSH2 0x88 JUMP JUMPDEST DUP1 PUSH4 0x79BA5097 EQ PUSH2 0x8D JUMPI DUP1 PUSH4 0x8DA5CB5B EQ PUSH2 0x97 JUMPI DUP1 PUSH4 0xBF5FC18B EQ PUSH2 0xC8 JUMPI DUP1 PUSH4 0xC0C9C7DB EQ PUSH2 0x101 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x95 PUSH2 0x20E JUMP JUMPDEST STOP JUMPDEST PUSH2 0x9F PUSH2 0x310 JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF SWAP1 SWAP3 AND DUP3 MSTORE MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x20 ADD SWAP1 RETURN JUMPDEST PUSH2 0x95 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0xDE JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP2 CALLDATALOAD AND SWAP1 PUSH1 0x20 ADD CALLDATALOAD PUSH2 0x32C JUMP JUMPDEST PUSH2 0x95 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x117 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP CALLDATALOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH2 0x3D6 JUMP JUMPDEST PUSH2 0x95 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x14A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP2 CALLDATALOAD DUP2 AND SWAP2 PUSH1 0x20 ADD CALLDATALOAD AND PUSH2 0x474 JUMP JUMPDEST PUSH2 0x95 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x185 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP2 CALLDATALOAD AND SWAP1 PUSH1 0x20 ADD CALLDATALOAD PUSH2 0x517 JUMP JUMPDEST PUSH2 0x95 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x1BE JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP CALLDATALOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH2 0x568 JUMP JUMPDEST PUSH2 0x95 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x1F1 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP CALLDATALOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH2 0x5AE JUMP JUMPDEST PUSH1 0x1 SLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER EQ PUSH2 0x294 JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x16 PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x4D7573742062652070726F706F736564206F776E657200000000000000000000 PUSH1 0x44 DUP3 ADD MSTORE SWAP1 MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x64 ADD SWAP1 REVERT JUMPDEST PUSH1 0x0 DUP1 SLOAD CALLER PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 DUP1 DUP4 AND DUP3 OR DUP5 SSTORE PUSH1 0x1 DUP1 SLOAD SWAP1 SWAP2 AND SWAP1 SSTORE PUSH1 0x40 MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF SWAP1 SWAP3 AND SWAP3 SWAP1 SWAP2 DUP4 SWAP2 PUSH32 0x8BE0079C531659141344CD1FD0A4F28419497F9722A3DAAFE3B4186F6B6457E0 SWAP2 LOG3 POP JUMP JUMPDEST PUSH1 0x0 SLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 JUMP JUMPDEST DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH4 0xB5AB58DC DUP3 PUSH1 0x40 MLOAD DUP3 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x37D JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x391 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x3A7 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP POP PUSH1 0x40 MLOAD PUSH32 0xFE92BBC330EB12CD316E909741296A7FBDE0684922F2564D9A9021F089593740 SWAP1 PUSH1 0x0 SWAP1 LOG1 POP POP JUMP JUMPDEST DUP1 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH4 0x50D25BCD PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x41C JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x430 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x446 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP POP PUSH1 0x40 MLOAD PUSH32 0xFE92BBC330EB12CD316E909741296A7FBDE0684922F2564D9A9021F089593740 SWAP1 PUSH1 0x0 SWAP1 LOG1 POP JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD PUSH32 0x88AA80E700000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP4 DUP2 AND PUSH1 0x4 DUP4 ADD MSTORE PUSH1 0x0 PUSH1 0x24 DUP4 ADD MSTORE SWAP2 MLOAD SWAP2 DUP5 AND SWAP2 PUSH4 0x88AA80E7 SWAP2 PUSH1 0x44 DUP1 DUP3 ADD SWAP3 PUSH2 0x100 SWAP3 SWAP1 SWAP2 SWAP1 DUP3 SWAP1 SUB ADD DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x4EC JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS STATICCALL ISZERO DUP1 ISZERO PUSH2 0x500 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH2 0x100 DUP2 LT ISZERO PUSH2 0x3A7 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH4 0xB633620C DUP3 PUSH1 0x40 MLOAD DUP3 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x37D JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH4 0x8205BF6A PUSH1 0x40 MLOAD DUP2 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP7 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x41C JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 SLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND CALLER EQ PUSH2 0x634 JUMPI PUSH1 0x40 DUP1 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x16 PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x4F6E6C792063616C6C61626C65206279206F776E657200000000000000000000 PUSH1 0x44 DUP3 ADD MSTORE SWAP1 MLOAD SWAP1 DUP2 SWAP1 SUB PUSH1 0x64 ADD SWAP1 REVERT JUMPDEST PUSH1 0x1 DUP1 SLOAD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP4 DUP2 AND SWAP2 DUP3 OR SWAP1 SWAP3 SSTORE PUSH1 0x0 DUP1 SLOAD PUSH1 0x40 MLOAD SWAP3 SWAP4 AND SWAP2 PUSH32 0xED8889F560326EB138920D842192F0EB3DD22B4F139C87A2C57538E05BAE1278 SWAP2 SWAP1 LOG3 POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 SMOD 0x2A 0xEE DUP10 BLOCKHASH MOD 0xAB SWAP6 DUP13 0xD2 0xD2 0x2F PUSH19 0x2DCACFDFF5705A1313B742D62B7A2FBA4C1FCC PUSH5 0x736F6C6343 STOP MOD MOD STOP CALLER ",
				"sourceMap": "58:831:38:-:0;;;;5:9:-1;2:2;;;27:1;24;17:12;2:2;58:831:38;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;12:1:-1;9;2:12;782:254:10;;;:::i;:::-;;147:28;;;:::i;:::-;;;;;;;;;;;;;;;;;;;572:152:38;;;;;;15:2:-1;10:3;7:11;4:2;;;31:1;28;21:12;4:2;-1:-1;572:152:38;;;;;;;;;:::i;294:132::-;;;;;;15:2:-1;10:3;7:11;4:2;;;31:1;28;21:12;4:2;-1:-1;294:132:38;;;;:::i;123:167::-;;;;;;15:2:-1;10:3;7:11;4:2;;;31:1;28;21:12;4:2;-1:-1;123:167:38;;;;;;;;;;;:::i;728:158::-;;;;;;15:2:-1;10:3;7:11;4:2;;;31:1;28;21:12;4:2;-1:-1;728:158:38;;;;;;;;;:::i;430:138::-;;;;;;15:2:-1;10:3;7:11;4:2;;;31:1;28;21:12;4:2;-1:-1;430:138:38;;;;:::i;543:150:10:-;;;;;;15:2:-1;10:3;7:11;4:2;;;31:1;28;21:12;4:2;-1:-1;543:150:10;;;;:::i;782:254::-;852:12;;;;838:10;:26;830:61;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;898:16;917:5;;936:10;928:18;;;;;;;;-1:-1:-1;952:25:10;;;;;;;989:42;;917:5;;;;;936:10;;917:5;;989:42;;;782:254;:::o;147:28::-;;;;;;:::o;572:152:38:-;670:11;655:37;;;693:8;655:47;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;5:9:-1;2:2;;;27:1;24;17:12;2:2;655:47:38;;;;8:9:-1;5:2;;;45:16;42:1;39;24:38;77:16;74:1;67:27;5:2;655:47:38;;;;;;;15:2:-1;10:3;7:11;4:2;;;31:1;28;21:12;4:2;-1:-1;;713:6:38;;;;;;;572:152;;:::o;294:132::-;377:11;362:40;;;:42;;;;;;;;;;;;;;;;;;;;;;5:9:-1;2:2;;;27:1;24;17:12;2:2;362:42:38;;;;8:9:-1;5:2;;;45:16;42:1;39;24:38;77:16;74:1;67:27;5:2;362:42:38;;;;;;;15:2:-1;10:3;7:11;4:2;;;31:1;28;21:12;4:2;-1:-1;;415:6:38;;;;;;;294:132;:::o;123:167::-;212:56;;;;;;:44;:56;;;;;;;266:1;212:56;;;;;;:44;;;;;;:56;;;;;;;;;;;;;;;:44;:56;;;2:2:-1;;;;27:1;24;17:12;2:2;212:56:38;;;;8:9:-1;5:2;;;45:16;42:1;39;24:38;77:16;74:1;67:27;5:2;212:56:38;;;;;;;15:3:-1;10;7:12;4:2;;;32:1;29;22:12;728:158:38;829:11;814:40;;;855:8;814:50;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;5:9:-1;2:2;;;27:1;24;17:12;430:138:38;516:11;501:43;;;:45;;;;;;;;;;;;;;;;;;;;;;5:9:-1;2:2;;;27:1;24;17:12;543:150:10;1170:5;;;;1156:10;:19;1148:54;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;620:12:::1;:18:::0;;;::::1;;::::0;;::::1;::::0;;::::1;::::0;;;-1:-1:-1;677:5:10;;650:38:::1;::::0;620:18;;677:5:::1;::::0;650:38:::1;::::0;-1:-1:-1;650:38:10::1;543:150:::0;:::o"
			},
			"methodIdentifiers": {
				"acceptOwnership()": "79ba5097",
				"owner()": "8da5cb5b",
				"readGetAnswer(address,uint256)": "bf5fc18b",
				"readGetTimestamp(address,uint256)": "c9592ab9",
				"readLatestAnswer(address)": "c0c9c7db",
				"readLatestTimestamp(address)": "d2f79c47",
				"readOracleRoundState(address,address)": "c52a1f5e",
				"transferOwnership(address)": "f2fde38b"
			}
		},
		"metadata": "{\"compiler\":{\"version\":\"0.6.6+commit.6c089d02\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[],\"name\":\"Here\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aggregator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_roundID\",\"type\":\"uint256\"}],\"name\":\"readGetAnswer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aggregator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_roundID\",\"type\":\"uint256\"}],\"name\":\"readGetTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aggregator\",\"type\":\"address\"}],\"name\":\"readLatestAnswer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aggregator\",\"type\":\"address\"}],\"name\":\"readLatestTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aggregator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"readOracleRoundState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{\"acceptOwnership()\":{\"details\":\"Allows an ownership transfer to be completed by the recipient.\"},\"transferOwnership(address)\":{\"details\":\"Allows an owner to begin transferring ownership to a new address, pending.\"}}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"/Users/steve/workspace/chainlink/evm-contracts/src/v0.6/tests/FluxAggregatorTestHelper.sol\":\"FluxAggregatorTestHelper\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[]},\"sources\":{\"/Users/steve/workspace/chainlink/evm-contracts/src/v0.6/FluxAggregator.sol\":{\"keccak256\":\"0x2496717fbc7565d56c6ce3fa6d0d064dd89bd12d7cba7b4ea42d1ad6bd95c798\",\"urls\":[\"bzz-raw://9a2057148fffccddba048d1962742ac6e5dcaed614d478faba42f2cfe2ec5f79\",\"dweb:/ipfs/QmQVrL5rko1sbn4YECQuMGYFJgu6d2jyRNmQGUZJAmtC9h\"]},\"/Users/steve/workspace/chainlink/evm-contracts/src/v0.6/Median.sol\":{\"keccak256\":\"0x7d5f7e0c161b9e0476ced988b190130c37a2141f13a91c664fd043226a98fb83\",\"urls\":[\"bzz-raw://396ee17f9cc94d4a55147273eb00de166de60415c2691cca92d953b2b6b6d65e\",\"dweb:/ipfs/QmUnPtGVpwDuMivPiZiv9zzCQXf2t4jsM38VS1oM4CV3WT\"]},\"/Users/steve/workspace/chainlink/evm-contracts/src/v0.6/Owned.sol\":{\"keccak256\":\"0x8cfbaaf9162c25fbdf40a1b38de6ec965e2c17d5f5e9b0f7ea814998a14a16cb\",\"urls\":[\"bzz-raw://173098f45ea9da30b932869ada24a37aea45c7f844858459527cdd4749f5c57f\",\"dweb:/ipfs/Qmb3dCZmkoLGPb6B1HTBtomd4kPHpwn1NhB71Z9SuKAksw\"]},\"/Users/steve/workspace/chainlink/evm-contracts/src/v0.6/SafeMath128.sol\":{\"keccak256\":\"0xf9f8d939c849cdb5e6d07ec317d01083b6e2554310633831ffe8a219a43be9e3\",\"urls\":[\"bzz-raw://ccf0f38e67d5df926bc9c9d9b916add6e1520a421e9215772b6d4eacfa53e21f\",\"dweb:/ipfs/QmVc1JVzseDtC38m9RH1voG4D1HvxKZ2RaYTquNjvEJJJ7\"]},\"/Users/steve/workspace/chainlink/evm-contracts/src/v0.6/SafeMath32.sol\":{\"keccak256\":\"0xdeb861fd382627ff8f614c942a98b96b701d719af81a1405caa41a1066272be7\",\"urls\":[\"bzz-raw://d8b977af733eda389474ea940fbdd8a989257100ed5341b85f56b271393eb161\",\"dweb:/ipfs/QmZGXnpsGNBpBt3NK24qeREkFiYZZfUN6L5mMfVfVoxM6y\"]},\"/Users/steve/workspace/chainlink/evm-contracts/src/v0.6/SafeMath64.sol\":{\"keccak256\":\"0x3185ad7d0afd2bd436a2702b33706e3e0f37b93b9db310346fcc26da3b1b47b7\",\"urls\":[\"bzz-raw://e50b02c9472176ad55ba4431e31ed33d9f58965b799c9a1eba7da1937f9f5534\",\"dweb:/ipfs/QmfJdQ3iS2HbWJFeukcNwiXTZzte6oCLHqzErbNrp1C59Z\"]},\"/Users/steve/workspace/chainlink/evm-contracts/src/v0.6/SignedSafeMath.sol\":{\"keccak256\":\"0x83e027df9251983d079e85187b87362d4898bc3052fd72ca365c89504b7f52ff\",\"urls\":[\"bzz-raw://3d56e6e2396d11b77828a3c6e531b525eb9d8c8a18e21aacac7284f46a74d8c0\",\"dweb:/ipfs/QmXvbrYGJVmnstRFZr3axhVT5ZCiWZSyCUnMu4p8jmNUHg\"]},\"/Users/steve/workspace/chainlink/evm-contracts/src/v0.6/interfaces/AggregatorInterface.sol\":{\"keccak256\":\"0x92566b76bfc7e5e5432dda7f473f8cd74b1a1849941ee913b86721d7a989c833\",\"urls\":[\"bzz-raw://573c3ac221d3544dbaf18be3f086ae0d229cc7dd76dd2700a3480e4baf430128\",\"dweb:/ipfs/QmU5eTZoxqvJVwfrhsksaJFbDWcPtZ9U1Ye6bUPqZaFXCy\"]},\"/Users/steve/workspace/chainlink/evm-contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\":{\"keccak256\":\"0xb724300fea77c1c9a14e0e4ddfc48a6e39e679874ab4243eaab779d2269f64f9\",\"urls\":[\"bzz-raw://75f80bb70da262a22b71c8759ab97f8770bbd4556621c098b33f0941cf7b44b6\",\"dweb:/ipfs/QmQ1sMw96vyMza533z8Fq7pmeRk2bbWeWRrywTutbKxGko\"]},\"/Users/steve/workspace/chainlink/evm-contracts/src/v0.6/interfaces/LinkTokenInterface.sol\":{\"keccak256\":\"0xdbf46b45a4c9f38ba71a0391aed0e7b108854b619f292d907ae537228868bda6\",\"urls\":[\"bzz-raw://3ae40466809630c4731e2e3a697d6885727c577aaf260766c8a2f534ad3f6ee8\",\"dweb:/ipfs/QmTzpN5yP4Y5jvQ1ohfXFrce3sjzUiSChYJgZj9VvhVohG\"]},\"/Users/steve/workspace/chainlink/evm-contracts/src/v0.6/tests/FluxAggregatorTestHelper.sol\":{\"keccak256\":\"0xff5d04c7782f0e8b5b703fa8e2f9b21fb324f742ffda57450576149417b19835\",\"urls\":[\"bzz-raw://f71053d854690d3f9b18d58f3d3b116fa8e20f223fd928000c602f880a813e93\",\"dweb:/ipfs/QmW8teXA3Hvrz5ff57kNzv86poh95APBWDzQ3PfiCgtbG4\"]},\"/Users/steve/workspace/chainlink/evm-contracts/src/v0.6/vendor/SafeMath.sol\":{\"keccak256\":\"0x95dbe2dd5ab8682b99bc3d7d297b621d4237442da160f78d3323ee5c4a06ded3\",\"urls\":[\"bzz-raw://d753308ff4eb43fba6f9ede371a33f707c5818350770dcb078a7d78ac8251361\",\"dweb:/ipfs/Qme64eYKWoTQiP3WhqGHoMqrENNZ9L8SdBLQ2hx5SmzUda\"]}},\"version\":1}",
		"userdoc": {
			"methods": {}
		}
	},
	"sources": {
		"tests/FluxAggregatorTestHelper.sol": {
			"id": 38
		},
		"FluxAggregator.sol": {
			"id": 6
		},
		"Median.sol": {
			"id": 8
		},
		"vendor/SafeMath.sol": {
			"id": 51
		},
		"SignedSafeMath.sol": {
			"id": 14
		},
		"Owned.sol": {
			"id": 10
		},
		"SafeMath128.sol": {
			"id": 11
		},
		"SafeMath32.sol": {
			"id": 12
		},
		"SafeMath64.sol": {
			"id": 13
		},
		"interfaces/AggregatorInterface.sol": {
			"id": 24
		},
		"interfaces/AggregatorV3Interface.sol": {
			"id": 25
		},
		"interfaces/LinkTokenInterface.sol": {
			"id": 28
		}
	},
	"sourceCodes": {
		"tests/FluxAggregatorTestHelper.sol": "pragma solidity ^0.6.0;\n\nimport \"../FluxAggregator.sol\";\n\ncontract FluxAggregatorTestHelper is Owned {\n\n  event Here();\n\n  function readOracleRoundState(address _aggregator, address _oracle)\n    external\n  {\n    FluxAggregator(_aggregator).oracleRoundState(_oracle, 0);\n    emit Here();\n  }\n\n  function readLatestAnswer(address _aggregator)\n    external\n  {\n    FluxAggregator(_aggregator).latestAnswer();\n    emit Here();\n  }\n\n  function readLatestTimestamp(address _aggregator)\n    external\n  {\n    FluxAggregator(_aggregator).latestTimestamp();\n    emit Here();\n  }\n\n  function readGetAnswer(address _aggregator, uint256 _roundID)\n    external\n  {\n    FluxAggregator(_aggregator).getAnswer(_roundID);\n    emit Here();\n  }\n\n  function readGetTimestamp(address _aggregator, uint256 _roundID)\n    external\n  {\n    FluxAggregator(_aggregator).getTimestamp(_roundID);\n    emit Here();\n  }\n\n}\n",
		"FluxAggregator.sol": "pragma solidity 0.6.6;\n\nimport \"./Median.sol\";\nimport \"./Owned.sol\";\nimport \"./SafeMath128.sol\";\nimport \"./SafeMath32.sol\";\nimport \"./SafeMath64.sol\";\nimport \"./interfaces/AggregatorInterface.sol\";\nimport \"./interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./vendor/SafeMath.sol\";\n\n/**\n * @title The Prepaid Aggregator contract\n * @notice Node handles aggregating data pushed in from off-chain, and unlocks\n * payment for oracles as they report. Oracles' submissions are gathered in\n * rounds, with each round aggregating the submissions for each oracle into a\n * single answer. The latest aggregated answer is exposed as well as historical\n * answers and their updated at timestamp.\n */\ncontract FluxAggregator is AggregatorInterface, AggregatorV3Interface, Owned {\n  using SafeMath for uint256;\n  using SafeMath128 for uint128;\n  using SafeMath64 for uint64;\n  using SafeMath32 for uint32;\n\n  struct Round {\n    int256 answer;\n    uint64 startedAt;\n    uint64 updatedAt;\n    uint32 answeredInRound;\n    RoundDetails details;\n  }\n\n  struct RoundDetails {\n    int256[] submissions;\n    uint32 maxSubmissions;\n    uint32 minSubmissions;\n    uint32 timeout;\n    uint128 paymentAmount;\n  }\n\n  struct OracleStatus {\n    uint128 withdrawable;\n    uint32 startingRound;\n    uint32 endingRound;\n    uint32 lastReportedRound;\n    uint32 lastStartedRound;\n    int256 latestSubmission;\n    uint16 index;\n    address admin;\n    address pendingAdmin;\n  }\n\n  struct Requester {\n    bool authorized;\n    uint32 delay;\n    uint32 lastStartedRound;\n  }\n\n\n  LinkTokenInterface public linkToken;\n  uint128 public allocatedFunds;\n  uint128 public availableFunds;\n\n  // Round related params\n  uint128 public paymentAmount;\n  uint32 public maxSubmissionCount;\n  uint32 public minSubmissionCount;\n  uint32 public restartDelay;\n  uint32 public timeout;\n  uint8 public override decimals;\n  string public override description;\n\n  int256 immutable public minSubmissionValue;\n  int256 immutable public maxSubmissionValue;\n\n  uint256 constant public override version = 3;\n\n  /**\n   * @notice To ensure owner isn't withdrawing required funds as oracles are\n   * submitting updates, we enforce that the contract maintains a minimum\n   * reserve of RESERVE_ROUNDS * oracleCount() LINK earmarked for payment to\n   * oracles. (Of course, this doesn't prevent the contract from running out of\n   * funds without the owner's intervention.)\n   */\n  uint256 constant private RESERVE_ROUNDS = 2;\n  uint256 constant private MAX_ORACLE_COUNT = 77;\n  uint32 constant private ROUND_MAX = 2**32-1;\n  // An error specific to the Aggregator V3 Interface, to prevent possible\n  // confusion around accidentally reading unset values as reported values.\n  string constant private V3_NO_DATA_ERROR = \"No data present\";\n\n  uint32 private reportingRoundId;\n  uint32 internal latestRoundId;\n  mapping(address => OracleStatus) private oracles;\n  mapping(uint32 => Round) internal rounds;\n  mapping(address => Requester) internal requesters;\n  address[] private oracleAddresses;\n\n  event AvailableFundsUpdated(\n    uint256 indexed amount\n  );\n  event RoundDetailsUpdated(\n    uint128 indexed paymentAmount,\n    uint32 indexed minSubmissionCount,\n    uint32 indexed maxSubmissionCount,\n    uint32 restartDelay,\n    uint32 timeout // measured in seconds\n  );\n  event OraclePermissionsUpdated(\n    address indexed oracle,\n    bool indexed whitelisted\n  );\n  event OracleAdminUpdated(\n    address indexed oracle,\n    address indexed newAdmin\n  );\n  event OracleAdminUpdateRequested(\n    address indexed oracle,\n    address admin,\n    address newAdmin\n  );\n  event SubmissionReceived(\n    int256 indexed submission,\n    uint32 indexed round,\n    address indexed oracle\n  );\n  event RequesterPermissionsSet(\n    address indexed requester,\n    bool authorized,\n    uint32 delay\n  );\n\n  /**\n   * @notice Deploy with the address of the LINK token and initial payment amount\n   * @dev Sets the LinkToken address and amount of LINK paid\n   * @param _link The address of the LINK token\n   * @param _paymentAmount The amount paid of LINK paid to each oracle per submission, in wei (units of 10⁻¹⁸ LINK)\n   * @param _timeout is the number of seconds after the previous round that are\n   * allowed to lapse before allowing an oracle to skip an unfinished round\n   */\n  constructor(\n    address _link,\n    uint128 _paymentAmount,\n    uint32 _timeout,\n    int256 _minSubmissionValue,\n    int256 _maxSubmissionValue,\n    uint8 _decimals,\n    string memory _description\n  ) public {\n    linkToken = LinkTokenInterface(_link);\n    paymentAmount = _paymentAmount;\n    timeout = _timeout;\n    minSubmissionValue = _minSubmissionValue;\n    maxSubmissionValue = _maxSubmissionValue;\n    decimals = _decimals;\n    description = _description;\n    rounds[0].updatedAt = uint64(block.timestamp.sub(uint256(_timeout)));\n  }\n\n  /**\n   * @notice called by oracles when they have witnessed a need to update\n   * @param _roundId is the ID of the round this submission pertains to\n   * @param _submission is the updated data that the oracle is submitting\n   */\n  function submit(uint256 _roundId, int256 _submission)\n    external\n  {\n    bytes memory error = validateOracleRound(msg.sender, uint32(_roundId));\n    require(_submission >= minSubmissionValue, \"value below minSubmissionValue\");\n    require(_submission <= maxSubmissionValue, \"value above maxSubmissionValue\");\n    require(error.length == 0, string(error));\n\n    oracleInitializeNewRound(uint32(_roundId));\n    recordSubmission(_submission, uint32(_roundId));\n    updateRoundAnswer(uint32(_roundId));\n    payOracle(uint32(_roundId));\n    deleteRoundDetails(uint32(_roundId));\n  }\n\n  /**\n   * @notice called by the owner to add new Oracles and update the round\n   * related parameters\n   * @param _oracles is the list of addresses of the new Oracles being added\n   * @param _admins is the admin addresses of the new respective _oracles list.\n   * Only this address is allowed to access the respective oracle's funds.\n   * @param _minSubmissions is the new minimum submission count for each round\n   * @param _maxSubmissions is the new maximum submission count for each round\n   * @param _restartDelay is the number of rounds an Oracle has to wait before\n   * they can initiate a round\n   */\n  function addOracles(\n    address[] calldata _oracles,\n    address[] calldata _admins,\n    uint32 _minSubmissions,\n    uint32 _maxSubmissions,\n    uint32 _restartDelay\n  )\n    external\n    onlyOwner()\n  {\n    require(_oracles.length == _admins.length, \"need same oracle and admin count\");\n    require(uint256(oracleCount()).add(_oracles.length) <= MAX_ORACLE_COUNT, \"max oracles allowed\");\n\n    for (uint256 i = 0; i < _oracles.length; i++) {\n      addOracle(_oracles[i], _admins[i]);\n    }\n\n    updateFutureRounds(paymentAmount, _minSubmissions, _maxSubmissions, _restartDelay, timeout);\n  }\n\n  /**\n   * @notice called by the owner to remove Oracles and update the round\n   * related parameters\n   * @param _oracles is the address of the Oracles being removed\n   * @param _minSubmissions is the new minimum submission count for each round\n   * @param _maxSubmissions is the new maximum submission count for each round\n   * @param _restartDelay is the number of rounds an Oracle has to wait before\n   * they can initiate a round\n   */\n  function removeOracles(\n    address[] calldata _oracles,\n    uint32 _minSubmissions,\n    uint32 _maxSubmissions,\n    uint32 _restartDelay\n  )\n    external\n    onlyOwner()\n  {\n    for (uint256 i = 0; i < _oracles.length; i++) {\n      removeOracle(_oracles[i]);\n    }\n\n    updateFutureRounds(paymentAmount, _minSubmissions, _maxSubmissions, _restartDelay, timeout);\n  }\n\n  /**\n   * @notice update the round and payment related parameters for subsequent\n   * rounds\n   * @param _paymentAmount is the payment amount for subsequent rounds\n   * @param _minSubmissions is the new minimum submission count for each round\n   * @param _maxSubmissions is the new maximum submission count for each round\n   * @param _restartDelay is the number of rounds an Oracle has to wait before\n   * they can initiate a round\n   */\n  function updateFutureRounds(\n    uint128 _paymentAmount,\n    uint32 _minSubmissions,\n    uint32 _maxSubmissions,\n    uint32 _restartDelay,\n    uint32 _timeout\n  )\n    public\n    onlyOwner()\n  {\n    uint32 oracleNum = oracleCount(); // Save on storage reads\n    require(_maxSubmissions >= _minSubmissions, \"max must equal/exceed min\");\n    require(oracleNum >= _maxSubmissions, \"max cannot exceed total\");\n    require(oracleNum == 0 || oracleNum > _restartDelay, \"delay cannot exceed total\");\n    require(availableFunds >= requiredReserve(_paymentAmount), \"insufficient funds for payment\");\n    if (oracleCount() > 0) {\n      require(_minSubmissions > 0, \"min must be greater than 0\");\n    }\n\n    paymentAmount = _paymentAmount;\n    minSubmissionCount = _minSubmissions;\n    maxSubmissionCount = _maxSubmissions;\n    restartDelay = _restartDelay;\n    timeout = _timeout;\n\n    emit RoundDetailsUpdated(\n      paymentAmount,\n      _minSubmissions,\n      _maxSubmissions,\n      _restartDelay,\n      _timeout\n    );\n  }\n\n  /**\n   * @notice recalculate the amount of LINK available for payouts\n   */\n  function updateAvailableFunds()\n    public\n  {\n    uint128 pastAvailableFunds = availableFunds;\n\n    uint256 available = linkToken.balanceOf(address(this)).sub(allocatedFunds);\n    availableFunds = uint128(available);\n\n    if (pastAvailableFunds != available) {\n      emit AvailableFundsUpdated(available);\n    }\n  }\n\n  /**\n   * @notice returns the number of oracles\n   */\n  function oracleCount() public view returns (uint32) {\n    return uint32(oracleAddresses.length);\n  }\n\n  /**\n   * @notice returns an array of addresses containing the oracles on contract\n   */\n  function getOracles() external view returns (address[] memory) {\n    return oracleAddresses;\n  }\n\n  /**\n   * @notice get the most recently reported answer\n   * @dev deprecated. Use latestRoundData instead.\n   */\n  function latestAnswer()\n    public\n    view\n    virtual\n    override\n    returns (int256)\n  {\n    return rounds[latestRoundId].answer;\n  }\n\n  /**\n   * @notice get the most recent updated at timestamp\n   * @dev deprecated. Use latestRoundData instead.\n   */\n  function latestTimestamp()\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return rounds[latestRoundId].updatedAt;\n  }\n\n  /**\n   * @notice get the ID of the last updated round\n   * @dev deprecated. Use latestRoundData instead.\n   */\n  function latestRound()\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return latestRoundId;\n  }\n\n  /**\n   * @notice get the ID of the round most recently reported on\n   */\n  function reportingRound()\n    external\n    view\n    returns (uint256)\n  {\n    return reportingRoundId;\n  }\n\n  /**\n   * @notice get past rounds answers\n   * @param _roundId the round number to retrieve the answer for\n   * @dev deprecated. Use getRoundData instead.\n   */\n  function getAnswer(uint256 _roundId)\n    public\n    view\n    virtual\n    override\n    returns (int256)\n  {\n    return rounds[uint32(_roundId)].answer;\n  }\n\n  /**\n   * @notice get timestamp when an answer was last updated\n   * @param _roundId the round number to retrieve the updated timestamp for\n   * @dev deprecated. Use getRoundData instead.\n   */\n  function getTimestamp(uint256 _roundId)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return rounds[uint32(_roundId)].updatedAt;\n  }\n\n  /**\n   * @notice get data about a round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt and\n   * answeredInRound return values.\n   * @param _roundId the round ID to retrieve the round data for\n   * @return roundId is the round ID for which data was retrieved\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started. This is 0\n   * if the round hasn't been started yet.\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed. answeredInRound may be smaller than roundId when the round\n   * timed out. answerInRound is equal to roundId when the round didn't time out\n   * and was completed regularly.\n   * @dev Note that for in-progress rounds (i.e. rounds that haven't yet received\n   * maxSubmissions) answer and updatedAt may change between queries.\n   */\n  function getRoundData(uint80 _roundId)\n    public\n    view\n    virtual\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    Round memory r = rounds[uint32(_roundId)];\n\n    require(r.answeredInRound > 0, V3_NO_DATA_ERROR);\n\n    return (\n      _roundId,\n      r.answer,\n      r.startedAt,\n      r.updatedAt,\n      r.answeredInRound\n    );\n  }\n\n  /**\n   * @notice get data about the latest round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt and\n   * answeredInRound return values. Consumers are encouraged to\n   * use this more fully featured method over the \"legacy\" getAnswer/\n   * latestAnswer/getTimestamp/latestTimestamp functions.\n   * @return roundId is the round ID for which data was retrieved\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started. This is 0\n   * if the round hasn't been started yet.\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed. answeredInRound may be smaller than roundId when the round\n   * timed out. answerInRound is equal to roundId when the round didn't time out\n   * and was completed regularly.\n   * @dev Note that for in-progress rounds (i.e. rounds that haven't yet received\n   * maxSubmissions) answer and updatedAt may change between queries.\n   */\n   function latestRoundData()\n    public\n    view\n    virtual\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return getRoundData(latestRoundId);\n  }\n\n\n  /**\n   * @notice query the available amount of LINK for an oracle to withdraw\n   */\n  function withdrawablePayment(address _oracle)\n    external\n    view\n    returns (uint256)\n  {\n    return oracles[_oracle].withdrawable;\n  }\n\n  /**\n   * @notice transfers the oracle's LINK to another address. Can only be called\n   * by the oracle's admin.\n   * @param _oracle is the oracle whose LINK is transferred\n   * @param _recipient is the address to send the LINK to\n   * @param _amount is the amount of LINK to send\n   */\n  function withdrawPayment(address _oracle, address _recipient, uint256 _amount)\n    external\n  {\n    require(oracles[_oracle].admin == msg.sender, \"only callable by admin\");\n\n    // Safe to downcast _amount because the total amount of LINK is less than 2^128.\n    uint128 amount = uint128(_amount);\n    uint128 available = oracles[_oracle].withdrawable;\n    require(available >= amount, \"insufficient withdrawable funds\");\n\n    oracles[_oracle].withdrawable = available.sub(amount);\n    allocatedFunds = allocatedFunds.sub(amount);\n\n    assert(linkToken.transfer(_recipient, uint256(amount)));\n  }\n\n  /**\n   * @notice transfers the owner's LINK to another address\n   * @param _recipient is the address to send the LINK to\n   * @param _amount is the amount of LINK to send\n   */\n  function withdrawFunds(address _recipient, uint256 _amount)\n    external\n    onlyOwner()\n  {\n    require(uint256(availableFunds).sub(requiredReserve(paymentAmount)) >= _amount, \"insufficient reserve funds\");\n    require(linkToken.transfer(_recipient, _amount), \"token transfer failed\");\n    updateAvailableFunds();\n  }\n\n  /**\n   * @notice get the latest submission for any oracle\n   * @param _oracle is the address to lookup the latest submission for\n   */\n  function latestSubmission(address _oracle)\n    external\n    view\n    returns (int256, uint256)\n  {\n    return (oracles[_oracle].latestSubmission, oracles[_oracle].lastReportedRound);\n  }\n\n  /**\n   * @notice get the admin address of an oracle\n   * @param _oracle is the address of the oracle whose admin is being queried\n   */\n  function getAdmin(address _oracle)\n    external\n    view\n    returns (address)\n  {\n    return oracles[_oracle].admin;\n  }\n\n  /**\n   * @notice transfer the admin address for an oracle\n   * @param _oracle is the address of the oracle whose admin is being transfered\n   * @param _newAdmin is the new admin address\n   */\n  function transferAdmin(address _oracle, address _newAdmin)\n    external\n  {\n    require(oracles[_oracle].admin == msg.sender, \"only callable by admin\");\n    oracles[_oracle].pendingAdmin = _newAdmin;\n\n    emit OracleAdminUpdateRequested(_oracle, msg.sender, _newAdmin);\n  }\n\n  /**\n   * @notice accept the admin address transfer for an oracle\n   * @param _oracle is the address of the oracle whose admin is being transfered\n   */\n  function acceptAdmin(address _oracle)\n    external\n  {\n    require(oracles[_oracle].pendingAdmin == msg.sender, \"only callable by pending admin\");\n    oracles[_oracle].pendingAdmin = address(0);\n    oracles[_oracle].admin = msg.sender;\n\n    emit OracleAdminUpdated(_oracle, msg.sender);\n  }\n\n  /**\n   * @notice allows non-oracles to request a new round\n   */\n  function requestNewRound()\n    external\n  {\n    require(requesters[msg.sender].authorized, \"not authorized requester\");\n\n    uint32 current = reportingRoundId;\n    require(rounds[current].updatedAt > 0 || timedOut(current), \"prev round must be supersedable\");\n\n    requesterInitializeNewRound(current.add(1));\n  }\n\n  /**\n   * @notice allows the owner to specify new non-oracles to start new rounds\n   * @param _requester is the address to set permissions for\n   * @param _authorized is a boolean specifying whether they can start new rounds or not\n   * @param _delay is the number of rounds the requester must wait before starting another round\n   */\n  function setRequesterPermissions(address _requester, bool _authorized, uint32 _delay)\n    external\n    onlyOwner()\n  {\n    if (requesters[_requester].authorized == _authorized) return;\n\n    if (_authorized) {\n      requesters[_requester].authorized = _authorized;\n      requesters[_requester].delay = _delay;\n    } else {\n      delete requesters[_requester];\n    }\n\n    emit RequesterPermissionsSet(_requester, _authorized, _delay);\n  }\n\n  /**\n   * @notice called through LINK's transferAndCall to update available funds\n   * in the same transaction as the funds were transfered to the aggregator\n   * @param _data is mostly ignored. It is checked for length, to be sure\n   * nothing strange is passed in.\n   */\n  function onTokenTransfer(address, uint256, bytes calldata _data)\n    external\n  {\n    require(_data.length == 0, \"transfer doesn't accept calldata\");\n    updateAvailableFunds();\n  }\n\n  /**\n   * @notice a method to provide all current info oracles need. Intended only\n   * only to be callable by oracles. Not for use by contracts to read state.\n   * @param _oracle the address to look up information for.\n   */\n  function oracleRoundState(address _oracle, uint32 _queriedRoundId)\n    external\n    view\n    returns (\n      bool _eligibleToSubmit,\n      uint32 _roundId,\n      int256 _latestSubmission,\n      uint64 _startedAt,\n      uint64 _timeout,\n      uint128 _availableFunds,\n      uint32 _oracleCount,\n      uint128 _paymentAmount\n    )\n  {\n    require(msg.sender == tx.origin, \"off-chain reading only\");\n\n    if (_queriedRoundId > 0) {\n      Round storage round = rounds[_queriedRoundId];\n      return (\n        eligibleForSpecificRound(_oracle, _queriedRoundId),\n        _queriedRoundId,\n        oracles[_oracle].latestSubmission,\n        round.startedAt,\n        round.details.timeout,\n        availableFunds,\n        oracleCount(),\n        (round.startedAt > 0 ? round.details.paymentAmount : paymentAmount)\n      );\n    } else {\n      return oracleRoundStateSuggestRound(_oracle);\n    }\n  }\n\n  function eligibleForSpecificRound(address _oracle, uint32 _queriedRoundId)\n    private\n    view\n    returns (bool _eligible)\n  {\n    if (rounds[_queriedRoundId].startedAt > 0) {\n      return acceptingSubmissions(_queriedRoundId) && validateOracleRound(_oracle, _queriedRoundId).length == 0;\n    } else {\n      return delayed(_oracle, _queriedRoundId) && validateOracleRound(_oracle, _queriedRoundId).length == 0;\n    }\n  }\n\n  function oracleRoundStateSuggestRound(address _oracle)\n    private\n    view\n    returns (\n      bool _eligibleToSubmit,\n      uint32 _roundId,\n      int256 _latestSubmission,\n      uint64 _startedAt,\n      uint64 _timeout,\n      uint128 _availableFunds,\n      uint32 _oracleCount,\n      uint128 _paymentAmount\n    )\n  {\n    Round storage round = rounds[0];\n    OracleStatus storage oracle = oracles[_oracle];\n\n    bool shouldSupersede = oracle.lastReportedRound == reportingRoundId || !acceptingSubmissions(reportingRoundId);\n    // Instead of nudging oracles to submit to the next round, the inclusion of\n    // the shouldSupersede bool in the if condition pushes them towards\n    // submitting in a currently open round.\n    if (supersedable(reportingRoundId) && shouldSupersede) {\n      _roundId = reportingRoundId.add(1);\n      round = rounds[_roundId];\n\n      _paymentAmount = paymentAmount;\n      _eligibleToSubmit = delayed(_oracle, _roundId);\n    } else {\n      _roundId = reportingRoundId;\n      round = rounds[_roundId];\n\n      _paymentAmount = round.details.paymentAmount;\n      _eligibleToSubmit = acceptingSubmissions(_roundId);\n    }\n\n    if (validateOracleRound(_oracle, _roundId).length != 0) {\n      _eligibleToSubmit = false;\n    }\n\n    return (\n      _eligibleToSubmit,\n      _roundId,\n      oracle.latestSubmission,\n      round.startedAt,\n      round.details.timeout,\n      availableFunds,\n      oracleCount(),\n      _paymentAmount\n    );\n  }\n\n\n  /**\n   * Private\n   */\n\n  function initializeNewRound(uint32 _roundId)\n    private\n  {\n    updateTimedOutRoundInfo(_roundId.sub(1));\n\n    reportingRoundId = _roundId;\n    rounds[_roundId].details.maxSubmissions = maxSubmissionCount;\n    rounds[_roundId].details.minSubmissions = minSubmissionCount;\n    rounds[_roundId].details.paymentAmount = paymentAmount;\n    rounds[_roundId].details.timeout = timeout;\n    rounds[_roundId].startedAt = uint64(block.timestamp);\n\n    emit NewRound(_roundId, msg.sender, rounds[_roundId].startedAt);\n  }\n\n  function oracleInitializeNewRound(uint32 _roundId)\n    private\n  {\n    if (!newRound(_roundId)) return;\n    uint256 lastStarted = oracles[msg.sender].lastStartedRound; // cache storage reads\n    if (_roundId <= lastStarted + restartDelay && lastStarted != 0) return;\n\n    initializeNewRound(_roundId);\n\n    oracles[msg.sender].lastStartedRound = _roundId;\n  }\n\n  function requesterInitializeNewRound(uint32 _roundId)\n    private\n  {\n    if (!newRound(_roundId)) return;\n    uint256 lastStarted = requesters[msg.sender].lastStartedRound; // cache storage reads\n    require(_roundId > lastStarted + requesters[msg.sender].delay || lastStarted == 0, \"must delay requests\");\n\n    initializeNewRound(_roundId);\n\n    requesters[msg.sender].lastStartedRound = _roundId;\n  }\n\n  function updateTimedOutRoundInfo(uint32 _roundId)\n    private\n  {\n    if (!timedOut(_roundId)) return;\n\n    uint32 prevId = _roundId.sub(1);\n    rounds[_roundId].answer = rounds[prevId].answer;\n    rounds[_roundId].answeredInRound = rounds[prevId].answeredInRound;\n    rounds[_roundId].updatedAt = uint64(block.timestamp);\n\n    delete rounds[_roundId].details;\n  }\n\n  function updateRoundAnswer(uint32 _roundId)\n    private\n  {\n    if (rounds[_roundId].details.submissions.length < rounds[_roundId].details.minSubmissions) return;\n\n    int256 newAnswer = Median.calculateInplace(rounds[_roundId].details.submissions);\n    rounds[_roundId].answer = newAnswer;\n    rounds[_roundId].updatedAt = uint64(block.timestamp);\n    rounds[_roundId].answeredInRound = _roundId;\n    latestRoundId = _roundId;\n\n    emit AnswerUpdated(newAnswer, _roundId, now);\n  }\n\n  function payOracle(uint32 _roundId)\n    private\n  {\n    uint128 payment = rounds[_roundId].details.paymentAmount;\n    uint128 available = availableFunds.sub(payment);\n\n    availableFunds = available;\n    allocatedFunds = allocatedFunds.add(payment);\n    oracles[msg.sender].withdrawable = oracles[msg.sender].withdrawable.add(payment);\n\n    emit AvailableFundsUpdated(available);\n  }\n\n  function recordSubmission(int256 _submission, uint32 _roundId)\n    private\n  {\n    require(acceptingSubmissions(_roundId), \"round not accepting submissions\");\n\n    rounds[_roundId].details.submissions.push(_submission);\n    oracles[msg.sender].lastReportedRound = _roundId;\n    oracles[msg.sender].latestSubmission = _submission;\n\n    emit SubmissionReceived(_submission, _roundId, msg.sender);\n  }\n\n  function deleteRoundDetails(uint32 _roundId)\n    private\n  {\n    if (rounds[_roundId].details.submissions.length < rounds[_roundId].details.maxSubmissions) return;\n\n    delete rounds[_roundId].details;\n  }\n\n  function timedOut(uint32 _roundId)\n    private\n    view\n    returns (bool)\n  {\n    uint64 startedAt = rounds[_roundId].startedAt;\n    uint32 roundTimeout = rounds[_roundId].details.timeout;\n    return startedAt > 0 && roundTimeout > 0 && startedAt.add(roundTimeout) < block.timestamp;\n  }\n\n  function getStartingRound(address _oracle)\n    private\n    view\n    returns (uint32)\n  {\n    uint32 currentRound = reportingRoundId;\n    if (currentRound != 0 && currentRound == oracles[_oracle].endingRound) {\n      return currentRound;\n    }\n    return currentRound.add(1);\n  }\n\n  function previousAndCurrentUnanswered(uint32 _roundId, uint32 _rrId)\n    private\n    view\n    returns (bool)\n  {\n    return _roundId.add(1) == _rrId && rounds[_rrId].updatedAt == 0;\n  }\n\n  function requiredReserve(uint256 payment)\n    private\n    view\n    returns (uint256)\n  {\n    return payment.mul(oracleCount()).mul(RESERVE_ROUNDS);\n  }\n\n  function addOracle(\n    address _oracle,\n    address _admin\n  )\n    private\n  {\n    require(!oracleEnabled(_oracle), \"oracle already enabled\");\n\n    require(_admin != address(0), \"cannot set admin to 0\");\n    require(oracles[_oracle].admin == address(0) || oracles[_oracle].admin == _admin, \"owner cannot overwrite admin\");\n\n    oracles[_oracle].startingRound = getStartingRound(_oracle);\n    oracles[_oracle].endingRound = ROUND_MAX;\n    oracles[_oracle].index = uint16(oracleAddresses.length);\n    oracleAddresses.push(_oracle);\n    oracles[_oracle].admin = _admin;\n\n    emit OraclePermissionsUpdated(_oracle, true);\n    emit OracleAdminUpdated(_oracle, _admin);\n  }\n\n  function removeOracle(\n    address _oracle\n  )\n    private\n  {\n    require(oracleEnabled(_oracle), \"oracle not enabled\");\n\n    oracles[_oracle].endingRound = reportingRoundId.add(1);\n    address tail = oracleAddresses[oracleCount().sub(1)];\n    uint16 index = oracles[_oracle].index;\n    oracles[tail].index = index;\n    delete oracles[_oracle].index;\n    oracleAddresses[index] = tail;\n    oracleAddresses.pop();\n\n    emit OraclePermissionsUpdated(_oracle, false);\n  }\n\n  function validateOracleRound(address _oracle, uint32 _roundId)\n    private\n    view\n    returns (bytes memory)\n  {\n    // cache storage reads\n    uint32 startingRound = oracles[_oracle].startingRound;\n    uint32 rrId = reportingRoundId;\n\n    if (startingRound == 0) return \"not enabled oracle\";\n    if (startingRound > _roundId) return \"not yet enabled oracle\";\n    if (oracles[_oracle].endingRound < _roundId) return \"no longer allowed oracle\";\n    if (oracles[_oracle].lastReportedRound >= _roundId) return \"cannot report on previous rounds\";\n    if (_roundId != rrId && _roundId != rrId.add(1) && !previousAndCurrentUnanswered(_roundId, rrId)) return \"invalid round to report\";\n    if (_roundId != 1 && !supersedable(_roundId.sub(1))) return \"previous round not supersedable\";\n  }\n\n  function supersedable(uint32 _roundId)\n    private\n    view\n    returns (bool)\n  {\n    return rounds[_roundId].updatedAt > 0 || timedOut(_roundId);\n  }\n\n  function oracleEnabled(address _oracle)\n    private\n    view\n    returns (bool)\n  {\n    return oracles[_oracle].endingRound == ROUND_MAX;\n  }\n\n  function acceptingSubmissions(uint32 _roundId)\n    private\n    view\n    returns (bool)\n  {\n    return rounds[_roundId].details.maxSubmissions != 0;\n  }\n\n  function delayed(address _oracle, uint32 _roundId)\n    private\n    view\n    returns (bool)\n  {\n    uint256 lastStarted = oracles[_oracle].lastStartedRound;\n    return _roundId > lastStarted + restartDelay || lastStarted == 0;\n  }\n\n  function newRound(uint32 _roundId)\n    private\n    view\n    returns (bool)\n  {\n    return _roundId == reportingRoundId.add(1);\n  }\n\n}\n",
		"Median.sol": "pragma solidity ^0.6.0;\n\nimport \"./vendor/SafeMath.sol\";\nimport \"./SignedSafeMath.sol\";\n\nlibrary Median {\n  using SignedSafeMath for int256;\n\n  int256 constant INT_MAX = 2**255-1;\n\n  /**\n   * @notice Returns the sorted middle, or the average of the two middle indexed items if the\n   * array has an even number of elements.\n   * @dev The list passed as an argument isn't modified.\n   * @dev This algorithm has expected runtime O(n), but for adversarially chosen inputs\n   * the runtime is O(n^2).\n   * @param list The list of elements to compare\n   */\n  function calculate(int256[] memory list)\n    internal\n    pure\n    returns (int256)\n  {\n    return calculateInplace(copy(list));\n  }\n\n  /**\n   * @notice See documentation for function calculate.\n   * @dev The list passed as an argument may be permuted.\n   */\n  function calculateInplace(int256[] memory list)\n    internal\n    pure\n    returns (int256)\n  {\n    require(0 < list.length, \"list must not be empty\");\n    uint256 len = list.length;\n    uint256 middleIndex = len / 2;\n    if (len % 2 == 0) {\n      int256 median1;\n      int256 median2;\n      (median1, median2) = quickselectTwo(list, 0, len - 1, middleIndex - 1, middleIndex);\n      return SignedSafeMath.avg(median1, median2);\n    } else {\n      return quickselect(list, 0, len - 1, middleIndex);\n    }\n  }\n\n  /**\n   * @notice Maximum length of list that shortSelectTwo can handle\n   */\n  uint256 constant SHORTSELECTTWO_MAX_LENGTH = 7;\n\n  /**\n   * @notice Select the k1-th and k2-th element from list of length at most 7\n   * @dev Uses an optimal sorting network\n   */\n  function shortSelectTwo(\n    int256[] memory list,\n    uint256 lo,\n    uint256 hi,\n    uint256 k1,\n    uint256 k2\n  )\n    private\n    pure\n    returns (int256 k1th, int256 k2th)\n  {\n    // Uses an optimal sorting network (https://en.wikipedia.org/wiki/Sorting_network)\n    // for lists of length 7. Network layout is taken from\n    // http://jgamble.ripco.net/cgi-bin/nw.cgi?inputs=7&algorithm=hibbard&output=svg\n\n    uint256 len = hi + 1 - lo;\n    int256 x0 = list[lo + 0];\n    int256 x1 = 1 < len ? list[lo + 1] : INT_MAX;\n    int256 x2 = 2 < len ? list[lo + 2] : INT_MAX;\n    int256 x3 = 3 < len ? list[lo + 3] : INT_MAX;\n    int256 x4 = 4 < len ? list[lo + 4] : INT_MAX;\n    int256 x5 = 5 < len ? list[lo + 5] : INT_MAX;\n    int256 x6 = 6 < len ? list[lo + 6] : INT_MAX;\n\n    if (x0 > x1) {(x0, x1) = (x1, x0);}\n    if (x2 > x3) {(x2, x3) = (x3, x2);}\n    if (x4 > x5) {(x4, x5) = (x5, x4);}\n    if (x0 > x2) {(x0, x2) = (x2, x0);}\n    if (x1 > x3) {(x1, x3) = (x3, x1);}\n    if (x4 > x6) {(x4, x6) = (x6, x4);}\n    if (x1 > x2) {(x1, x2) = (x2, x1);}\n    if (x5 > x6) {(x5, x6) = (x6, x5);}\n    if (x0 > x4) {(x0, x4) = (x4, x0);}\n    if (x1 > x5) {(x1, x5) = (x5, x1);}\n    if (x2 > x6) {(x2, x6) = (x6, x2);}\n    if (x1 > x4) {(x1, x4) = (x4, x1);}\n    if (x3 > x6) {(x3, x6) = (x6, x3);}\n    if (x2 > x4) {(x2, x4) = (x4, x2);}\n    if (x3 > x5) {(x3, x5) = (x5, x3);}\n    if (x3 > x4) {(x3, x4) = (x4, x3);}\n\n    uint256 index1 = k1 - lo;\n    if (index1 == 0) {k1th = x0;}\n    else if (index1 == 1) {k1th = x1;}\n    else if (index1 == 2) {k1th = x2;}\n    else if (index1 == 3) {k1th = x3;}\n    else if (index1 == 4) {k1th = x4;}\n    else if (index1 == 5) {k1th = x5;}\n    else if (index1 == 6) {k1th = x6;}\n    else {revert(\"k1 out of bounds\");}\n\n    uint256 index2 = k2 - lo;\n    if (k1 == k2) {return (k1th, k1th);}\n    else if (index2 == 0) {return (k1th, x0);}\n    else if (index2 == 1) {return (k1th, x1);}\n    else if (index2 == 2) {return (k1th, x2);}\n    else if (index2 == 3) {return (k1th, x3);}\n    else if (index2 == 4) {return (k1th, x4);}\n    else if (index2 == 5) {return (k1th, x5);}\n    else if (index2 == 6) {return (k1th, x6);}\n    else {revert(\"k2 out of bounds\");}\n  }\n\n  /**\n   * @notice Selects the k-th ranked element from list, looking only at indices between lo and hi\n   * (inclusive). Modifies list in-place.\n   */\n  function quickselect(int256[] memory list, uint256 lo, uint256 hi, uint256 k)\n    private\n    pure\n    returns (int256 kth)\n  {\n    require(lo <= k);\n    require(k <= hi);\n    while (lo < hi) {\n      if (hi - lo < SHORTSELECTTWO_MAX_LENGTH) {\n        int256 ignore;\n        (kth, ignore) = shortSelectTwo(list, lo, hi, k, k);\n        return kth;\n      }\n      uint256 pivotIndex = partition(list, lo, hi);\n      if (k <= pivotIndex) {\n        // since pivotIndex < (original hi passed to partition),\n        // termination is guaranteed in this case\n        hi = pivotIndex;\n      } else {\n        // since (original lo passed to partition) <= pivotIndex,\n        // termination is guaranteed in this case\n        lo = pivotIndex + 1;\n      }\n    }\n    return list[lo];\n  }\n\n  /**\n   * @notice Selects the k1-th and k2-th ranked elements from list, looking only at indices between\n   * lo and hi (inclusive). Modifies list in-place.\n   */\n  function quickselectTwo(\n    int256[] memory list,\n    uint256 lo,\n    uint256 hi,\n    uint256 k1,\n    uint256 k2\n  )\n    internal // for testing\n    pure\n    returns (int256 k1th, int256 k2th)\n  {\n    require(k1 < k2);\n    require(lo <= k1 && k1 <= hi);\n    require(lo <= k2 && k2 <= hi);\n\n    while (true) {\n      if (hi - lo < SHORTSELECTTWO_MAX_LENGTH) {\n        return shortSelectTwo(list, lo, hi, k1, k2);\n      }\n      uint256 pivotIdx = partition(list, lo, hi);\n      if (k2 <= pivotIdx) {\n        hi = pivotIdx;\n      } else if (pivotIdx < k1) {\n        lo = pivotIdx + 1;\n      } else {\n        assert(k1 <= pivotIdx && pivotIdx < k2);\n        k1th = quickselect(list, lo, pivotIdx, k1);\n        k2th = quickselect(list, pivotIdx + 1, hi, k2);\n        return (k1th, k2th);\n      }\n    }\n  }\n\n  /**\n   * @notice Partitions list in-place using Hoare's partitioning scheme.\n   * Only elements of list between indices lo and hi (inclusive) will be modified.\n   * Returns an index i, such that:\n   * - lo <= i < hi\n   * - forall j in [lo, i]. list[j] <= list[i]\n   * - forall j in [i, hi]. list[i] <= list[j]\n   */\n  function partition(int256[] memory list, uint256 lo, uint256 hi)\n    private\n    pure\n    returns (uint256)\n  {\n    // We don't care about overflow of the addition, because it would require a list\n    // larger than any feasible computer's memory.\n    int256 pivot = list[(lo + hi) / 2];\n    lo -= 1; // this can underflow. that's intentional.\n    hi += 1;\n    while (true) {\n      do {\n        lo += 1;\n      } while (list[lo] < pivot);\n      do {\n        hi -= 1;\n      } while (list[hi] > pivot);\n      if (lo < hi) {\n        (list[lo], list[hi]) = (list[hi], list[lo]);\n      } else {\n        // Let orig_lo and orig_hi be the original values of lo and hi passed to partition.\n        // Then, hi < orig_hi, because hi decreases *strictly* monotonically\n        // in each loop iteration and\n        // - either list[orig_hi] > pivot, in which case the first loop iteration\n        //   will achieve hi < orig_hi;\n        // - or list[orig_hi] <= pivot, in which case at least two loop iterations are\n        //   needed:\n        //   - lo will have to stop at least once in the interval\n        //     [orig_lo, (orig_lo + orig_hi)/2]\n        //   - (orig_lo + orig_hi)/2 < orig_hi\n        return hi;\n      }\n    }\n  }\n\n  /**\n   * @notice Makes an in-memory copy of the array passed in\n   * @param list Reference to the array to be copied\n   */\n  function copy(int256[] memory list)\n    private\n    pure\n    returns(int256[] memory)\n  {\n    int256[] memory list2 = new int256[](list.length);\n    for (uint256 i = 0; i < list.length; i++) {\n      list2[i] = list[i];\n    }\n    return list2;\n  }\n}\n",
		"vendor/SafeMath.sol": "pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n  /**\n    * @dev Returns the addition of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `+` operator.\n    *\n    * Requirements:\n    * - Addition cannot overflow.\n    */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the subtraction of two unsigned integers, reverting on\n    * overflow (when the result is negative).\n    *\n    * Counterpart to Solidity's `-` operator.\n    *\n    * Requirements:\n    * - Subtraction cannot overflow.\n    */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"SafeMath: subtraction overflow\");\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the multiplication of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `*` operator.\n    *\n    * Requirements:\n    * - Multiplication cannot overflow.\n    */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the integer division of two unsigned integers. Reverts on\n    * division by zero. The result is rounded towards zero.\n    *\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\n    * uses an invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, \"SafeMath: division by zero\");\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n    * Reverts when dividing by zero.\n    *\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\n    * invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"SafeMath: modulo by zero\");\n    return a % b;\n  }\n}\n",
		"SignedSafeMath.sol": "pragma solidity ^0.6.0;\n\nlibrary SignedSafeMath {\n  int256 constant private _INT256_MIN = -2**255;\n\n  /**\n   * @dev Multiplies two signed integers, reverts on overflow.\n   */\n  function mul(int256 a, int256 b) internal pure returns (int256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n    int256 c = a * b;\n    require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n   * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n   */\n  function div(int256 a, int256 b) internal pure returns (int256) {\n    require(b != 0, \"SignedSafeMath: division by zero\");\n    require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n    int256 c = a / b;\n\n    return c;\n  }\n\n  /**\n   * @dev Subtracts two signed integers, reverts on overflow.\n   */\n  function sub(int256 a, int256 b) internal pure returns (int256) {\n    int256 c = a - b;\n    require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n    return c;\n  }\n\n  /**\n   * @dev Adds two signed integers, reverts on overflow.\n   */\n  function add(int256 a, int256 b) internal pure returns (int256) {\n    int256 c = a + b;\n    require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n   * @notice Computes average of two signed integers, ensuring that the computation\n   * doesn't overflow.\n   * @dev If the result is not an integer, it is rounded towards zero. For example,\n   * avg(-3, -4) = -3\n   */\n  function avg(int256 _a, int256 _b)\n    internal\n    pure\n    returns (int256)\n  {\n    if ((_a < 0 && _b > 0) || (_a > 0 && _b < 0)) {\n      return add(_a, _b) / 2;\n    }\n    int256 remainder = (_a % 2 + _b % 2) / 2;\n    return add(add(_a / 2, _b / 2), remainder);\n  }\n}\n",
		"Owned.sol": "pragma solidity ^0.6.0;\n\n/**\n * @title The Owned contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract Owned {\n\n  address payable public owner;\n  address private pendingOwner;\n\n  event OwnershipTransferRequested(\n    address indexed from,\n    address indexed to\n  );\n  event OwnershipTransferred(\n    address indexed from,\n    address indexed to\n  );\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(address _to)\n    external\n    onlyOwner()\n  {\n    pendingOwner = _to;\n\n    emit OwnershipTransferRequested(owner, _to);\n  }\n\n  /**\n   * @dev Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership()\n    external\n  {\n    require(msg.sender == pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = owner;\n    owner = msg.sender;\n    pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @dev Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Only callable by owner\");\n    _;\n  }\n\n}\n",
		"SafeMath128.sol": "pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * This library is a version of Open Zeppelin's SafeMath, modified to support\n * unsigned 128 bit integers.\n */\nlibrary SafeMath128 {\n  /**\n    * @dev Returns the addition of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `+` operator.\n    *\n    * Requirements:\n    * - Addition cannot overflow.\n    */\n  function add(uint128 a, uint128 b) internal pure returns (uint128) {\n    uint128 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the subtraction of two unsigned integers, reverting on\n    * overflow (when the result is negative).\n    *\n    * Counterpart to Solidity's `-` operator.\n    *\n    * Requirements:\n    * - Subtraction cannot overflow.\n    */\n  function sub(uint128 a, uint128 b) internal pure returns (uint128) {\n    require(b <= a, \"SafeMath: subtraction overflow\");\n    uint128 c = a - b;\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the multiplication of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `*` operator.\n    *\n    * Requirements:\n    * - Multiplication cannot overflow.\n    */\n  function mul(uint128 a, uint128 b) internal pure returns (uint128) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint128 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the integer division of two unsigned integers. Reverts on\n    * division by zero. The result is rounded towards zero.\n    *\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\n    * uses an invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function div(uint128 a, uint128 b) internal pure returns (uint128) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, \"SafeMath: division by zero\");\n    uint128 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n    * Reverts when dividing by zero.\n    *\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\n    * invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function mod(uint128 a, uint128 b) internal pure returns (uint128) {\n    require(b != 0, \"SafeMath: modulo by zero\");\n    return a % b;\n  }\n}\n",
		"SafeMath32.sol": "pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * This library is a version of Open Zeppelin's SafeMath, modified to support\n * unsigned 32 bit integers.\n */\nlibrary SafeMath32 {\n  /**\n    * @dev Returns the addition of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `+` operator.\n    *\n    * Requirements:\n    * - Addition cannot overflow.\n    */\n  function add(uint32 a, uint32 b) internal pure returns (uint32) {\n    uint32 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the subtraction of two unsigned integers, reverting on\n    * overflow (when the result is negative).\n    *\n    * Counterpart to Solidity's `-` operator.\n    *\n    * Requirements:\n    * - Subtraction cannot overflow.\n    */\n  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n    require(b <= a, \"SafeMath: subtraction overflow\");\n    uint32 c = a - b;\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the multiplication of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `*` operator.\n    *\n    * Requirements:\n    * - Multiplication cannot overflow.\n    */\n  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint32 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the integer division of two unsigned integers. Reverts on\n    * division by zero. The result is rounded towards zero.\n    *\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\n    * uses an invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function div(uint32 a, uint32 b) internal pure returns (uint32) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, \"SafeMath: division by zero\");\n    uint32 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n    * Reverts when dividing by zero.\n    *\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\n    * invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function mod(uint32 a, uint32 b) internal pure returns (uint32) {\n    require(b != 0, \"SafeMath: modulo by zero\");\n    return a % b;\n  }\n}\n",
		"SafeMath64.sol": "pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * This library is a version of Open Zeppelin's SafeMath, modified to support\n * unsigned 64 bit integers.\n */\nlibrary SafeMath64 {\n  /**\n    * @dev Returns the addition of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `+` operator.\n    *\n    * Requirements:\n    * - Addition cannot overflow.\n    */\n  function add(uint64 a, uint64 b) internal pure returns (uint64) {\n    uint64 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the subtraction of two unsigned integers, reverting on\n    * overflow (when the result is negative).\n    *\n    * Counterpart to Solidity's `-` operator.\n    *\n    * Requirements:\n    * - Subtraction cannot overflow.\n    */\n  function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n    require(b <= a, \"SafeMath: subtraction overflow\");\n    uint64 c = a - b;\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the multiplication of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `*` operator.\n    *\n    * Requirements:\n    * - Multiplication cannot overflow.\n    */\n  function mul(uint64 a, uint64 b) internal pure returns (uint64) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint64 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the integer division of two unsigned integers. Reverts on\n    * division by zero. The result is rounded towards zero.\n    *\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\n    * uses an invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function div(uint64 a, uint64 b) internal pure returns (uint64) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, \"SafeMath: division by zero\");\n    uint64 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n    * Reverts when dividing by zero.\n    *\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\n    * invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function mod(uint64 a, uint64 b) internal pure returns (uint64) {\n    require(b != 0, \"SafeMath: modulo by zero\");\n    return a % b;\n  }\n}\n",
		"interfaces/AggregatorInterface.sol": "pragma solidity >=0.6.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n",
		"interfaces/AggregatorV3Interface.sol": "pragma solidity >=0.6.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n",
		"interfaces/LinkTokenInterface.sol": "pragma solidity ^0.6.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n  function approve(address spender, uint256 value) external returns (bool success);\n  function balanceOf(address owner) external view returns (uint256 balance);\n  function decimals() external view returns (uint8 decimalPlaces);\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n  function name() external view returns (string memory tokenName);\n  function symbol() external view returns (string memory tokenSymbol);\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n  function transfer(address to, uint256 value) external returns (bool success);\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"
	},
	"sourceTreeHashHex": "0xa651f7228b71f3587f13f8391db2fa36ade303cf096624c87d92fb428a7f1cc7",
	"compiler": {
		"name": "solc",
		"version": "soljson-v0.6.6+commit.6c089d02.js",
		"settings": {
			"optimizer": {
				"runs": 1000000,
				"enabled": true
			},
			"outputSelection": {
				"*": {
					"*": [
						"abi",
						"devdoc",
						"userdoc",
						"evm.bytecode.object",
						"evm.bytecode.sourceMap",
						"evm.deployedBytecode.object",
						"evm.deployedBytecode.sourceMap",
						"evm.methodIdentifiers",
						"metadata"
					]
				}
			},
			"remappings": []
		}
	},
	"chains": {}
}